---
description: 
globs: 
alwaysApply: false
---
Jesteś doświadczonym inżynierem QA, którego zadaniem jest stworzenie kompleksowego planu testów dla projektu programistycznego. Przeanalizuj poniższe informacje o projekcie:

<kod_projektu>
================================================
FILE: README.md
================================================
# AI Flashcards

AI Flashcards is an empathetic web application designed to streamline the learning process by automatically transforming any text into high-quality educational flashcards. Powered by AI, the app generates questions, answers, context, tags, and difficulty levels, allowing users to focus on learning rather than content creation.

## Table of Contents
- [Project Description](#project-description)
- [Tech Stack](#tech-stack)
- [Getting Started Locally](#getting-started-locally)
- [Available Scripts](#available-scripts)
- [Project Scope](#project-scope)
- [Project Status](#project-status)
- [License](#license)

---

## Project Description

The manual creation of flashcards is often a bottleneck in effective learning. AI Flashcards solves this by providing:
- **Instant Generation:** Copy-paste text to receive AI-suggested flashcards.
- **Smart Metadata:** Automatic tagging, difficulty assessment, and context extraction.
- **Manual Control:** A robust inline editor for refining AI suggestions and batch processing.
- **Progress Tracking:** Real-time session goals and statistics.
- **Seamless Integration:** Export data to existing Spaced Repetition Systems (SRS) via JSON/CSV or API.

---

## Tech Stack

### Frontend
- **Astro 5:** High-performance web framework for content-focused websites.
- **React 19:** Used for interactive components like the flashcard editor and filtering systems.
- **TypeScript 5:** For type-safe development.
- **Tailwind CSS 4:** Utility-first styling.
- **Shadcn/ui:** High-quality accessible UI components.

### Backend & AI
- **Supabase:** Managed PostgreSQL database, Authentication, and Row Level Security (RLS).
- **Openrouter.ai:** Unified API for accessing various AI models (OpenAI, Anthropic, Google, etc.).

### Infrastructure
- **GitHub Actions:** Automated CI/CD pipelines.
- **DigitalOcean + Docker:** Containerized hosting and deployment.

---

## Getting Started Locally

### Prerequisites
- **Node.js:** Version `22.14.0` (as specified in `.nvmrc`).
- **Package Manager:** `npm` (included with Node.js).

### Installation

1. **Clone the repository:**
   ```bash
   git clone https://github.com/your-username/10xdevs-project.git
   cd 10xdevs-project
   ```

2. **Install dependencies:**
   ```bash
   npm install
   ```

3. **Start local Supabase (database + API):**
   ```bash
   npx supabase start
   ```
   To apply migrations to your local database:
   ```bash
   npx supabase db reset
   ```
   Notes:
   - `npx supabase db reset` resets local DB (destructive) and re-applies migrations from `supabase/migrations/`.
   - The project uses an RPC for atomic daily limit enforcement: `public.increment_daily_generation(...)`.

3. **Set up Environment Variables:**
   Create a `.env` file in the root directory and add your credentials:
   ```env
   PUBLIC_SUPABASE_URL=your_supabase_url
   PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
   SUPABASE_URL=your_supabase_url
   SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key
   OPENROUTER_API_KEY=your_openrouter_api_key
   DEFAULT_USER_ID=your_existing_profiles_id_uuid
   ```
   Notes:
   - `DEFAULT_USER_ID` is a temporary development shortcut (auth will be added later). It must match an existing `public.profiles.id` in your local Supabase DB.

4. **Start the development server:**
   ```bash
   npm run dev
   ```
   The application will be available at `http://localhost:4321`.

---

## Available Scripts

| Command | Description |
| :--- | :--- |
| `npm run dev` | Starts the local development server with hot-reloading. |
| `npm run build` | Builds the production-ready application. |
| `npm run preview` | Previews the production build locally. |
| `npm run lint` | Runs ESLint to check for code quality issues. |
| `npm run lint:fix` | Automatically fixes linting errors where possible. |
| `npm run format` | Formats the codebase using Prettier. |

---

## Project Scope

### MVP Features
- AI-powered flashcard generation from raw text.
- Manual inline editor with batch actions (approve, reject, tag).
- User authentication (Demo vs. Full accounts).
- Usage limits enforcement (2,000 flashcards, 50 decks, 5 generations/day).
- Session progress monitoring and KPI tracking.
- JSON/CSV export for SRS synchronization.

### Out of Scope (MVP)
- Native mobile application (Web-only).
- Direct PDF/DOCX file imports (Copy-paste only).
- Social features or deck sharing between users.
- Built-in advanced SRS algorithm (Integration via export/API).

---

## Project Status

The project is currently in the **MVP Development Phase** as part of a 10-week roadmap.
- [x] Phase 1: Data & Architecture Setup
- [ ] Phase 2: Core AI Generation & Editor Implementation
- [ ] Phase 3: SRS Integration & KPI Testing
- [ ] Phase 4: Final Launch & Optimization

---

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.



================================================
FILE: astro.config.mjs
================================================
// @ts-check
import { defineConfig } from "astro/config";

import react from "@astrojs/react";
import sitemap from "@astrojs/sitemap";
import tailwindcss from "@tailwindcss/vite";
import node from "@astrojs/node";

// https://astro.build/config
export default defineConfig({
  output: "server",
  integrations: [react(), sitemap()],
  server: { port: 3000 },
  vite: {
    plugins: [tailwindcss()],
  },
  adapter: node({
    mode: "standalone",
  }),
});



================================================
FILE: components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/styles/global.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: eslint.config.js
================================================
import { includeIgnoreFile } from "@eslint/compat";
import eslint from "@eslint/js";
import eslintPluginPrettier from "eslint-plugin-prettier/recommended";
import eslintPluginAstro from "eslint-plugin-astro";
import jsxA11y from "eslint-plugin-jsx-a11y";
import pluginReact from "eslint-plugin-react";
import reactCompiler from "eslint-plugin-react-compiler";
import eslintPluginReactHooks from "eslint-plugin-react-hooks";
import path from "node:path";
import { fileURLToPath } from "node:url";
import tseslint from "typescript-eslint";

// File path setup
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const gitignorePath = path.resolve(__dirname, ".gitignore");

const baseConfig = tseslint.config({
  extends: [eslint.configs.recommended, tseslint.configs.strict, tseslint.configs.stylistic],
  rules: {
    "no-console": "warn",
    "no-unused-vars": "off",
  },
});

const jsxA11yConfig = tseslint.config({
  files: ["**/*.{js,jsx,ts,tsx}"],
  extends: [jsxA11y.flatConfigs.recommended],
  languageOptions: {
    ...jsxA11y.flatConfigs.recommended.languageOptions,
  },
  rules: {
    ...jsxA11y.flatConfigs.recommended.rules,
  },
});

const reactConfig = tseslint.config({
  files: ["**/*.{js,jsx,ts,tsx}"],
  extends: [pluginReact.configs.flat.recommended],
  languageOptions: {
    ...pluginReact.configs.flat.recommended.languageOptions,
    globals: {
      window: true,
      document: true,
    },
  },
  plugins: {
    "react-hooks": eslintPluginReactHooks,
    "react-compiler": reactCompiler,
  },
  settings: { react: { version: "detect" } },
  rules: {
    ...eslintPluginReactHooks.configs.recommended.rules,
    "react/react-in-jsx-scope": "off",
    "react-compiler/react-compiler": "error",
  },
});

export default tseslint.config(
  includeIgnoreFile(gitignorePath),
  baseConfig,
  jsxA11yConfig,
  reactConfig,
  eslintPluginAstro.configs["flat/recommended"],
  eslintPluginPrettier
);



================================================
FILE: package.json
================================================
{
  "name": "10x-astro-starter",
  "type": "module",
  "version": "0.0.1",
  "scripts": {
    "dev": "astro dev",
    "build": "astro build",
    "preview": "astro preview",
    "astro": "astro",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write ."
  },
  "dependencies": {
    "@astrojs/node": "^9.4.3",
    "@astrojs/react": "^4.3.1",
    "@astrojs/sitemap": "^3.5.1",
    "@radix-ui/react-slot": "^1.1.2",
    "@supabase/supabase-js": "^2.93.3",
    "@tailwindcss/vite": "^4.1.13",
    "@types/react": "^19.1.12",
    "@types/react-dom": "^19.1.9",
    "astro": "^5.13.7",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.487.0",
    "react": "^19.1.1",
    "react-dom": "^19.1.1",
    "tailwind-merge": "^3.1.0",
    "tailwindcss": "^4.1.13",
    "tw-animate-css": "^1.2.5",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@eslint/compat": "1.2.7",
    "@eslint/js": "9.23.0",
    "@typescript-eslint/eslint-plugin": "8.28.0",
    "@typescript-eslint/parser": "8.28.0",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-import-resolver-typescript": "4.2.5",
    "eslint-plugin-astro": "1.3.1",
    "eslint-plugin-import": "2.31.0",
    "eslint-plugin-jsx-a11y": "6.10.2",
    "eslint-plugin-prettier": "5.2.5",
    "eslint-plugin-react": "7.37.4",
    "eslint-plugin-react-compiler": "19.0.0-beta-aeaed83-20250323",
    "eslint-plugin-react-hooks": "5.2.0",
    "husky": "9.1.7",
    "lint-staged": "15.5.0",
    "prettier-plugin-astro": "0.14.1",
    "supabase": "^2.74.1",
    "typescript-eslint": "8.28.0"
  },
  "lint-staged": {
    "*.{ts,tsx,astro}": [
      "eslint --fix"
    ],
    "*.{json,css,md}": [
      "prettier --write"
    ]
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"],
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "react",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}



================================================
FILE: .env.example
================================================
PUBLIC_SUPABASE_URL=###
PUBLIC_SUPABASE_ANON_KEY=###
SUPABASE_URL=###
SUPABASE_SERVICE_ROLE_KEY=###
OPENROUTER_API_KEY=###
OPENROUTER_DEFAULT_MODEL=openai/gpt-5.2
OPENROUTER_HTTP_REFERER=http://localhost:4321
OPENROUTER_X_TITLE=10xdevs
OPENROUTER_TIMEOUT_MS=45000
DEFAULT_USER_ID=###


================================================
FILE: .nvmrc
================================================
22.14.0


================================================
FILE: .prettierrc.json
================================================
{
  "semi": true,
  "singleQuote": false,
  "tabWidth": 2,
  "printWidth": 120,
  "trailingComma": "es5",
  "plugins": ["prettier-plugin-astro"],
  "overrides": [
    {
      "files": "*.astro",
      "options": {
        "parser": "astro"
      }
    }
  ]
}



================================================
FILE: .windsurfrules
================================================
# AI Rules for {{project-name}}

{{project-description}}

## Tech Stack

- Astro 5
- TypeScript 5
- React 19
- Tailwind 4
- Shadcn/ui

## Project Structure

When introducing changes to the project, always follow the directory structure below:

- `./src` - source code
- `./src/layouts` - Astro layouts
- `./src/pages` - Astro pages
- `./src/pages/api` - API endpoints
- `./src/middleware/index.ts` - Astro middleware
- `./src/db` - Supabase clients and types
- `./src/types.ts` - Shared types for backend and frontend (Entities, DTOs)
- `./src/components` - Client-side components written in Astro (static) and React (dynamic)
- `./src/components/ui` - Client-side components from Shadcn/ui
- `./src/lib` - Services and helpers
- `./src/assets` - static internal assets
- `./public` - public assets

When modifying the directory structure, always update this section.

## Coding practices

### Guidelines for clean code

- Use feedback from linters to improve the code when making changes.
- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deeply nested if statements.
- Place the happy path last in the function for improved readability.
- Avoid unnecessary else statements; use if-return pattern instead.
- Use guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Consider using custom error types or error factories for consistent error handling.

## Frontend

### General Guidelines

- Use Astro components (.astro) for static content and layout
- Implement framework components in React only when interactivity is needed

### Guidelines for Styling

#### Tailwind

- Use the @layer directive to organize styles into components, utilities, and base layers
- Use arbitrary values with square brackets (e.g., w-[123px]) for precise one-off designs
- Implement the Tailwind configuration file for customizing theme, plugins, and variants
- Leverage the theme() function in CSS for accessing Tailwind theme values
- Implement dark mode with the dark: variant
- Use responsive variants (sm:, md:, lg:, etc.) for adaptive designs
- Leverage state variants (hover:, focus-visible:, active:, etc.) for interactive elements

### Guidelines for Accessibility

#### ARIA Best Practices

- Use ARIA landmarks to identify regions of the page (main, navigation, search, etc.)
- Apply appropriate ARIA roles to custom interface elements that lack semantic HTML equivalents
- Set aria-expanded and aria-controls for expandable content like accordions and dropdowns
- Use aria-live regions with appropriate politeness settings for dynamic content updates
- Implement aria-hidden to hide decorative or duplicative content from screen readers
- Apply aria-label or aria-labelledby for elements without visible text labels
- Use aria-describedby to associate descriptive text with form inputs or complex elements
- Implement aria-current for indicating the current item in a set, navigation, or process
- Avoid redundant ARIA that duplicates the semantics of native HTML elements

### Guidelines for Astro

- Leverage View Transitions API for smooth page transitions (use ClientRouter)
- Use content collections with type safety for blog posts, documentation, etc.
- Leverage Server Endpoints for API routes
- Use POST, GET  - uppercase format for endpoint handlers
- Use `export const prerender = false` for API routes
- Use zod for input validation in API routes
- Extract logic into services in `src/lib/services`
- Implement middleware for request/response modification
- Use image optimization with the Astro Image integration
- Implement hybrid rendering with server-side rendering where needed
- Use Astro.cookies for server-side cookie management
- Leverage import.meta.env for environment variables

### Guidelines for React

- Use functional components with hooks instead of class components
- Never use "use client" and other Next.js directives as we use React with Astro
- Extract logic into custom hooks in `src/components/hooks`
- Implement React.memo() for expensive components that render often with the same props
- Utilize React.lazy() and Suspense for code-splitting and performance optimization
- Use the useCallback hook for event handlers passed to child components to prevent unnecessary re-renders
- Prefer useMemo for expensive calculations to avoid recomputation on every render
- Implement useId() for generating unique IDs for accessibility attributes
- Consider using the new useOptimistic hook for optimistic UI updates in forms
- Use useTransition for non-urgent state updates to keep the UI responsive

### Backend and Database

- Use Supabase for backend services, including authentication and database interactions.
- Follow Supabase guidelines for security and performance.
- Use Zod schemas to validate data exchanged with the backend.
- Use supabase from context.locals in Astro routes instead of importing supabaseClient directly
- Use SupabaseClient type from `src/db/supabase.client.ts`, not from `@supabase/supabase-js`


================================================
FILE: scripts/create-dev-user.mjs
================================================
import { execSync } from "node:child_process";
import { createClient } from "@supabase/supabase-js";

function getSupabaseStatus() {
  const raw = execSync("npx supabase status --output json", {
    stdio: ["ignore", "pipe", "pipe"],
    encoding: "utf8",
  });
  return JSON.parse(raw);
}

function pick(obj, key) {
  if (!obj || typeof obj !== "object") return undefined;
  return obj[key];
}

const status = getSupabaseStatus();
const apiUrl = pick(status, "API_URL");
const anonKey = pick(status, "ANON_KEY");
const serviceRoleKey = pick(status, "SERVICE_ROLE_KEY");

if (!apiUrl || !anonKey || !serviceRoleKey) {
  console.error("Missing API_URL / ANON_KEY / SERVICE_ROLE_KEY from `supabase status`.");
  process.exit(1);
}

const supabaseAnon = createClient(apiUrl, anonKey, {
  auth: { persistSession: false, autoRefreshToken: false },
});

const supabaseService = createClient(apiUrl, serviceRoleKey, {
  auth: { persistSession: false, autoRefreshToken: false },
});

const email = `dev+${Date.now()}@example.com`;
const password = "dev-password-123!";

// Create an auth user via public sign-up (works in local dev).
const { data, error } = await supabaseAnon.auth.signUp({ email, password });

if (error) {
  console.error(JSON.stringify(error));
  process.exit(2);
}

const userId = data.user?.id;
if (!userId) {
  console.error("Failed to create user (missing id).");
  process.exit(3);
}

// Ensure a matching profile exists (FKs from other tables depend on it).
const { error: profileErr } = await supabaseService.from("profiles").upsert(
  {
    id: userId,
    email,
    account_role: "demo",
  },
  { onConflict: "id" },
);

if (profileErr) {
  console.error(JSON.stringify(profileErr));
  process.exit(4);
}

// Print only the user id (so it can be copied into DEFAULT_USER_ID).
process.stdout.write(userId);




================================================
FILE: src/env.d.ts
================================================
/// <reference types="astro/client" />

import type { SupabaseClient } from './db/supabase.client.ts';

declare global {
  namespace App {
    interface Locals {
      supabase: SupabaseClient;
    }
  }
}

interface ImportMetaEnv {
  readonly PUBLIC_SUPABASE_URL: string;
  readonly PUBLIC_SUPABASE_ANON_KEY: string;
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
  readonly SUPABASE_SERVICE_ROLE_KEY: string;
  readonly OPENROUTER_API_KEY: string;
  readonly OPENROUTER_DEFAULT_MODEL: string;
  readonly OPENROUTER_HTTP_REFERER: string;
  readonly OPENROUTER_X_TITLE: string;
  readonly OPENROUTER_TIMEOUT_MS: string;
  readonly DEFAULT_USER_ID: string;
  // more env variables...
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}



================================================
FILE: src/types.ts
================================================
import type { Tables, TablesInsert, TablesUpdate } from "./db/database.types";

type DbCard = Tables<"cards">;
type DbDeck = Tables<"decks">;
type DbSource = Tables<"sources">;
type DbProfile = Tables<"profiles">;

// API-level enums derived from known business rules in the API plan.
export type CardQualityStatus = "draft" | "ok" | "good";
export type AccountRole = "demo" | "full";

export type PaginationMeta = {
  total: number;
  page: number;
  limit: number;
};

export type DeckDto = Pick<DbDeck, "id" | "name" | "description" | "created_at">;

export type CardDto = Pick<
  DbCard,
  | "id"
  | "question"
  | "answer"
  | "context"
  | "difficulty"
  | "tags"
  | "quality_status"
  | "deck_id"
  | "source_id"
  | "created_at"
  | "updated_at"
>;

export type ListDecksQuery = {
  page?: number;
  limit?: number;
  search?: string;
};

export type ListDecksResponseDto = {
  data: DeckDto[];
  meta: PaginationMeta;
};

export type GetDeckResponseDto = {
  data: DeckDto;
};

export type DeckCreateCommand = Pick<TablesInsert<"decks">, "name" | "description">;

export type DeckUpdateCommand = Pick<TablesUpdate<"decks">, "name" | "description">;

export type ListCardsQuery = {
  deck_id?: DbDeck["id"];
  source_id?: DbSource["id"];
  quality_status?: CardQualityStatus;
  tags?: string[];
  sort?: string;
};

export type ListCardsResponseDto = {
  data: CardDto[];
  meta: PaginationMeta;
};

export type CardCreateCommand = Pick<
  TablesInsert<"cards">,
  "question" | "answer" | "context" | "deck_id" | "tags" | "difficulty"
>;

// API accepts a single object or an array of objects.
export type CardsCreateCommand = CardCreateCommand | CardCreateCommand[];

export type CardUpdateCommand = Pick<
  TablesUpdate<"cards">,
  | "question"
  | "answer"
  | "context"
  | "deck_id"
  | "tags"
  | "difficulty"
  | "quality_status"
>;

export type BatchUpdateCardsCommand = {
  card_ids: DbCard["id"][];
  action: "update_status" | "add_tags" | "delete";
  payload: {
    quality_status?: CardQualityStatus;
    tags?: DbCard["tags"];
  };
};

export type GenerateCardsCommand = {
  content: string;
  deck_id?: DbDeck["id"];
};

export type GeneratedCardDto = {
  id: DbCard["id"];
  // API uses front/back while database uses question/answer.
  front: DbCard["question"];
  back: DbCard["answer"];
  context: DbCard["context"];
  difficulty: DbCard["difficulty"];
  tags: DbCard["tags"];
  quality_status: CardQualityStatus;
};

export type GenerateCardsResponseDto = {
  source_id: DbSource["id"];
  cards: GeneratedCardDto[];
  remaining_generations: number;
};

export type UserStatusDto = {
  id: DbProfile["id"];
  role: AccountRole;
  limits: {
    cards_created: number;
    cards_limit: number;
    decks_created: number;
    decks_limit: number;
    daily_generations_used: number;
    daily_generations_limit: number;
  };
};

export type ExportQueryCommand = {
  deck_id?: DbDeck["id"];
  format: "json" | "csv";
};



================================================
FILE: src/components/Welcome.astro
================================================
<div
  class="relative w-full mx-auto min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-blue-900 p-4 sm:p-8"
>
  <div
    class="relative max-w-4xl mx-auto backdrop-blur-xl bg-gradient-to-b from-white/10 to-white/5 rounded-2xl shadow-2xl p-8 text-white border border-white/10"
  >
    <div class="space-y-8">
      <div class="text-center">
        <h1
          class="text-6xl font-bold mb-4 bg-gradient-to-r from-blue-200 via-purple-200 to-pink-200 text-transparent bg-clip-text drop-shadow-lg"
        >
          Witaj w 10xDevs Astro Starter!
        </h1>
        <p class="text-xl text-blue-100/90 drop-shadow-md">
          Ten projekt został zbudowany w oparciu o nowoczesny stack technologiczny:
        </p>
      </div>

      <div class="flex flex-col gap-6 max-w-2xl mx-auto">
        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Core
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Astro v5.5.5</span>
              <span class="text-blue-100/90">- Metaframework do aplikacji webowych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">React v19</span>
              <span class="text-blue-100/90">- Biblioteka UI do komponentów interaktywnych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">TypeScript</span>
              <span class="text-blue-100/90">- Typowanie statyczne</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Stylowanie
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Tailwind CSS v4</span
              >
              <span class="text-blue-100/90">- Utility-first CSS framework</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Statyczna analiza kodu
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">ESLint v9</span>
              <span class="text-blue-100/90">- Lintowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Prettier</span>
              <span class="text-blue-100/90">- Formatowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Husky i Lint-staged</span
              >
              <span class="text-blue-100/90">- Automatyczna analiza kodu przed commitowaniem</span>
            </li>
          </ul>
        </div>
      </div>

      <p class="text-lg text-center text-blue-100/90 mt-8 leading-relaxed">
        Starter zawiera wszystko, czego potrzebujesz do rozpoczęcia tworzenia <br class="hidden sm:block" />
        <span class="font-semibold bg-gradient-to-r from-blue-200 to-purple-200 text-transparent bg-clip-text"
          >nowoczesnych aplikacji webowych!</span
        >
      </p>
    </div>
  </div>
</div>



================================================
FILE: src/components/generate/CreateDeckModal.tsx
================================================
import { useEffect, useId, useState, type FormEvent } from "react";
import type { DeckCreateCommand } from "@/types";
import { Button } from "@/components/ui/button";

type CreateDeckModalProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSubmit: (command: DeckCreateCommand) => void;
  isSubmitting?: boolean;
  errorMessage?: string | null;
};

const MAX_NAME_LENGTH = 100;

export function CreateDeckModal({
  open,
  onOpenChange,
  onSubmit,
  isSubmitting,
  errorMessage,
}: CreateDeckModalProps) {
  const nameId = useId();
  const descriptionId = useId();
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [touched, setTouched] = useState(false);

  useEffect(() => {
    if (open) {
      return;
    }

    setName("");
    setDescription("");
    setTouched(false);
  }, [open]);

  if (!open) {
    return null;
  }

  const trimmedName = name.trim();
  const isNameTooLong = trimmedName.length > MAX_NAME_LENGTH;
  const isNameMissing = trimmedName.length === 0;
  const isInvalid = isNameMissing || isNameTooLong;

  const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setTouched(true);

    if (isInvalid) {
      return;
    }

    onSubmit({
      name: trimmedName,
      description: description.trim() ? description.trim() : undefined,
    });
  };

  const handleClose = () => {
    onOpenChange(false);
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40 px-4">
      <div
        role="dialog"
        aria-modal="true"
        className="w-full max-w-lg rounded-lg bg-white p-6 shadow-lg"
      >
        <header className="space-y-1">
          <h2 className="text-lg font-semibold">Utwórz nowy deck</h2>
          <p className="text-sm text-neutral-500">
            Dodaj nazwę i opcjonalny opis, aby od razu przypisać fiszki.
          </p>
        </header>
        <form className="mt-4 space-y-4" onSubmit={handleSubmit}>
          <div className="space-y-2">
            <label className="text-sm font-medium" htmlFor={nameId}>
              Nazwa decka
            </label>
            <input
              id={nameId}
              className="min-h-[40px] w-full rounded-md border border-neutral-200 px-3 text-sm shadow-sm outline-none transition focus-visible:ring-2 focus-visible:ring-neutral-400"
              value={name}
              onChange={(event) => setName(event.target.value)}
              onBlur={() => setTouched(true)}
              maxLength={MAX_NAME_LENGTH}
              aria-invalid={touched && isInvalid ? true : undefined}
            />
            {touched && isNameMissing ? (
              <p className="text-xs text-red-600" role="alert">
                Nazwa decka jest wymagana.
              </p>
            ) : null}
            {touched && isNameTooLong ? (
              <p className="text-xs text-red-600" role="alert">
                Maksymalnie {MAX_NAME_LENGTH} znaków.
              </p>
            ) : null}
          </div>
          <div className="space-y-2">
            <label className="text-sm font-medium" htmlFor={descriptionId}>
              Opis (opcjonalnie)
            </label>
            <textarea
              id={descriptionId}
              className="min-h-[100px] w-full rounded-md border border-neutral-200 p-3 text-sm shadow-sm outline-none transition focus-visible:ring-2 focus-visible:ring-neutral-400"
              value={description}
              onChange={(event) => setDescription(event.target.value)}
            />
          </div>
          {errorMessage ? (
            <p className="text-xs text-red-600" role="alert">
              {errorMessage}
            </p>
          ) : null}
          <div className="flex flex-col gap-2 sm:flex-row sm:justify-end">
            <Button type="button" variant="ghost" onClick={handleClose}>
              Anuluj
            </Button>
            <Button type="submit" disabled={isSubmitting || isInvalid}>
              {isSubmitting ? "Tworzę..." : "Utwórz"}
            </Button>
          </div>
        </form>
      </div>
    </div>
  );
}



================================================
FILE: src/components/generate/DeckPicker.tsx
================================================
import { useId } from "react";
import type { DeckOptionVm } from "@/lib/viewmodels/generate.vm";
import { Button } from "@/components/ui/button";

type DeckPickerProps = {
  value: string | null;
  options: DeckOptionVm[];
  disabled?: boolean;
  helperText?: string;
  createDisabled?: boolean;
  onChange: (deckId: string | null) => void;
  onCreateDeck: () => void;
};

export function DeckPicker({
  value,
  options,
  disabled,
  helperText,
  createDisabled,
  onChange,
  onCreateDeck,
}: DeckPickerProps) {
  const selectId = useId();

  return (
    <div className="space-y-2">
      <label className="text-sm font-medium" htmlFor={selectId}>
        Deck docelowy
      </label>
      <div className="flex flex-col gap-2 sm:flex-row sm:items-center">
        <select
          id={selectId}
          className="min-h-[40px] w-full rounded-md border border-neutral-200 bg-white px-3 text-sm shadow-sm outline-none transition focus-visible:ring-2 focus-visible:ring-neutral-400 disabled:cursor-not-allowed disabled:opacity-60"
          value={value ?? ""}
          onChange={(event) => {
            const nextValue = event.target.value;
            onChange(nextValue === "" ? null : nextValue);
          }}
          disabled={disabled}
        >
          {options.map((option) => (
            <option key={option.value ?? "none"} value={option.value ?? ""}>
              {option.label}
            </option>
          ))}
        </select>
        <Button
          type="button"
          variant="outline"
          onClick={onCreateDeck}
          disabled={disabled || createDisabled}
        >
          Utwórz deck
        </Button>
      </div>
      {helperText ? (
        <p className="text-xs text-neutral-500">{helperText}</p>
      ) : null}
    </div>
  );
}



================================================
FILE: src/components/generate/GenerateProgressPanel.tsx
================================================
import type {
  GenerateApiErrorVm,
  GenerateRequestStateVm,
} from "@/lib/viewmodels/generate.vm";
import { Button } from "@/components/ui/button";

type GenerateProgressPanelProps = {
  state: GenerateRequestStateVm;
  error?: GenerateApiErrorVm | null;
  onRetry?: () => void;
};

export function GenerateProgressPanel({
  state,
  error,
  onRetry,
}: GenerateProgressPanelProps) {
  if (state.status === "idle") {
    return (
      <div className="rounded-md border border-neutral-200 bg-white p-4 text-sm text-neutral-600">
        Wypełnij formularz, aby rozpocząć generowanie fiszek.
      </div>
    );
  }

  if (state.status === "loading") {
    return (
      <div className="rounded-md border border-neutral-200 bg-white p-4 text-sm text-neutral-600">
        Generuję fiszki. To może potrwać chwilę...
      </div>
    );
  }

  if (state.status === "success") {
    return (
      <div className="rounded-md border border-emerald-200 bg-emerald-50 p-4 text-sm text-emerald-700">
        Gotowe! Przekierowuję do wyników generacji.
      </div>
    );
  }

  return (
    <div className="space-y-3 rounded-md border border-red-200 bg-red-50 p-4 text-sm text-red-700">
      <p>{error?.message ?? "Coś poszło nie tak. Spróbuj ponownie."}</p>
      {onRetry ? (
        <Button type="button" variant="outline" onClick={onRetry}>
          Spróbuj ponownie
        </Button>
      ) : null}
    </div>
  );
}



================================================
FILE: src/components/generate/GenerateResultsView.tsx
================================================
import { useEffect, useMemo, useState } from "react";
import type { CardDto } from "@/types";
import { getCardsBySourceId } from "@/lib/services/source-cards-client.service";
import { deleteCard, updateCard } from "@/lib/services/cards-client.service";
import { Button } from "@/components/ui/button";

type Status = "idle" | "loading" | "success" | "error";

function getSourceIdFromLocation(): string | null {
  if (typeof window === "undefined") return null;
  const url = new URL(window.location.href);
  return url.searchParams.get("source_id");
}

export function GenerateResultsView() {
  const sourceId = useMemo(() => getSourceIdFromLocation(), []);
  const [status, setStatus] = useState<Status>("idle");
  const [cards, setCards] = useState<CardDto[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [draft, setDraft] = useState<{ question: string; answer: string } | null>(null);
  const [savingId, setSavingId] = useState<string | null>(null);
  const [deletingId, setDeletingId] = useState<string | null>(null);

  useEffect(() => {
    if (!sourceId) {
      setStatus("error");
      setError("Brak parametru source_id w URL.");
      return;
    }

    let isMounted = true;
    const run = async () => {
      setStatus("loading");
      setError(null);
      try {
        const data = await getCardsBySourceId(sourceId);
        if (!isMounted) return;
        setCards(data);
        setStatus("success");
      } catch {
        if (!isMounted) return;
        setStatus("error");
        setError("Nie udało się pobrać wygenerowanych fiszek.");
      }
    };

    run();
    return () => {
      isMounted = false;
    };
  }, [sourceId]);

  const startEdit = (card: CardDto) => {
    setEditingId(card.id);
    setDraft({ question: card.question, answer: card.answer });
  };

  const cancelEdit = () => {
    setEditingId(null);
    setDraft(null);
  };

  const saveEdit = async (cardId: string) => {
    if (!draft) return;
    setSavingId(cardId);
    try {
      const updated = await updateCard(cardId, {
        question: draft.question,
        answer: draft.answer,
      });
      setCards((prev) => prev.map((c) => (c.id === cardId ? updated : c)));
      cancelEdit();
    } catch {
      setError("Nie udało się zapisać zmian. Spróbuj ponownie.");
    } finally {
      setSavingId(null);
    }
  };

  const removeCard = async (cardId: string) => {
    if (typeof window !== "undefined") {
      const ok = window.confirm("Na pewno usunąć tę fiszkę? Tej operacji nie da się cofnąć.");
      if (!ok) return;
    }
    setDeletingId(cardId);
    try {
      await deleteCard(cardId);
      setCards((prev) => prev.filter((c) => c.id !== cardId));
      if (editingId === cardId) {
        cancelEdit();
      }
    } catch {
      setError("Nie udało się usunąć fiszki. Spróbuj ponownie.");
    } finally {
      setDeletingId(null);
    }
  };

  return (
    <main className="mx-auto flex w-full max-w-5xl flex-col gap-6 px-4 py-10">
      <header className="space-y-2">
        <p className="text-xs uppercase tracking-[0.2em] text-neutral-500">Generowanie fiszek</p>
        <h1 className="text-3xl font-semibold text-neutral-900">Wyniki</h1>
        <p className="text-sm text-neutral-600">Twoje fiszki wygenerowane z podanego źródła.</p>
      </header>

      <div className="flex items-center justify-between gap-4">
        <Button asChild variant="outline" size="sm">
          <a href="/generate">← Wróć do generatora</a>
        </Button>
        <p className="text-xs text-neutral-500">
          Źródło: <span className="font-mono">{sourceId ?? "—"}</span>
        </p>
      </div>

      {status === "loading" ? (
        <div className="rounded-xl border border-neutral-200 bg-white p-6 text-sm text-neutral-600">
          Ładuję fiszki...
        </div>
      ) : null}

      {status === "error" ? (
        <div className="rounded-xl border border-red-200 bg-red-50 p-6 text-sm text-red-800">{error}</div>
      ) : null}

      {status === "success" ? (
        <section className="space-y-4">
          {cards.length === 0 ? (
            <div className="rounded-xl border border-neutral-200 bg-white p-6 text-sm text-neutral-600">
              Brak fiszek dla tego źródła.
            </div>
          ) : (
            <ul className="grid gap-4 md:grid-cols-2">
              {cards.map((card) => (
                <li key={card.id} className="rounded-xl border border-neutral-200 bg-white p-5 shadow-sm">
                  <div className="flex items-start justify-between gap-3">
                    <div className="min-w-0">
                      <p className="text-xs font-medium uppercase tracking-[0.2em] text-neutral-500">Front</p>
                      {editingId === card.id && draft ? (
                        <input
                          value={draft.question}
                          onChange={(e) => setDraft({ ...draft, question: e.target.value })}
                          className="mt-1 w-full rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900"
                        />
                      ) : (
                        <p className="mt-1 text-sm font-medium text-neutral-900">{card.question}</p>
                      )}
                    </div>
                    <div className="flex shrink-0 flex-col gap-2">
                      {editingId === card.id ? (
                        <>
                          <Button
                            size="sm"
                            onClick={() => saveEdit(card.id)}
                            disabled={savingId === card.id || deletingId === card.id}
                          >
                            {savingId === card.id ? "Zapisuję..." : "Zapisz"}
                          </Button>
                          <Button
                            size="sm"
                            variant="outline"
                            onClick={cancelEdit}
                            disabled={savingId === card.id || deletingId === card.id}
                          >
                            Anuluj
                          </Button>
                        </>
                      ) : (
                        <>
                          <Button size="sm" variant="outline" onClick={() => startEdit(card)}>
                            Edytuj
                          </Button>
                          <Button
                            size="sm"
                            variant="destructive"
                            onClick={() => removeCard(card.id)}
                            disabled={deletingId === card.id}
                          >
                            {deletingId === card.id ? "Usuwam..." : "Usuń"}
                          </Button>
                        </>
                      )}
                    </div>
                  </div>
                  <div className="my-4 h-px bg-neutral-100" />
                  <p className="text-xs font-medium uppercase tracking-[0.2em] text-neutral-500">Back</p>
                  {editingId === card.id && draft ? (
                    <textarea
                      value={draft.answer}
                      onChange={(e) => setDraft({ ...draft, answer: e.target.value })}
                      rows={5}
                      className="mt-1 w-full resize-y rounded-md border border-neutral-200 bg-white px-3 py-2 text-sm text-neutral-900"
                    />
                  ) : (
                    <p className="mt-1 whitespace-pre-wrap text-sm text-neutral-800">{card.answer}</p>
                  )}
                </li>
              ))}
            </ul>
          )}
        </section>
      ) : null}
    </main>
  );
}




================================================
FILE: src/components/generate/GenerateSubmitButton.tsx
================================================
import { Button } from "@/components/ui/button";

type GenerateSubmitButtonProps = {
  disabled: boolean;
  loading: boolean;
  label?: string;
};

export function GenerateSubmitButton({
  disabled,
  loading,
  label = "Generuj",
}: GenerateSubmitButtonProps) {
  return (
    <Button type="submit" disabled={disabled} aria-busy={loading}>
      {loading ? "Generuję..." : label}
    </Button>
  );
}



================================================
FILE: src/components/generate/GenerateTextInput.tsx
================================================
import { useId } from "react";

type GenerateTextInputProps = {
  value: string;
  minLength: number;
  maxLength: number;
  disabled?: boolean;
  validation?: { state: "idle" | "error"; message?: string };
  onContentChange: (next: string) => void;
  onBlur?: () => void;
  onClear?: () => void;
};

export function GenerateTextInput({
  value,
  minLength,
  maxLength,
  disabled,
  validation,
  onContentChange,
  onBlur,
  onClear,
}: GenerateTextInputProps) {
  const textareaId = useId();
  const helpId = useId();
  const errorId = useId();
  const isError = validation?.state === "error";
  const describedBy = isError ? `${helpId} ${errorId}` : helpId;

  return (
    <div className="space-y-2">
      <label className="text-sm font-medium" htmlFor={textareaId}>
        Tekst źródłowy
      </label>
      <textarea
        id={textareaId}
        className="min-h-[220px] w-full rounded-md border border-neutral-200 bg-white p-3 text-sm shadow-sm outline-none transition focus-visible:ring-2 focus-visible:ring-neutral-400 disabled:cursor-not-allowed disabled:opacity-60"
        placeholder="Wklej materiał do wygenerowania fiszek..."
        value={value}
        onChange={(event) => onContentChange(event.target.value)}
        onBlur={onBlur}
        disabled={disabled}
        aria-invalid={isError || undefined}
        aria-describedby={describedBy}
      />
      <div className="flex items-center justify-between text-xs text-neutral-500">
        <p id={helpId}>
          Min {minLength}, max {maxLength} znaków
        </p>
        <span>
          {value.length} / {maxLength}
        </span>
      </div>
      {isError ? (
        <p id={errorId} className="text-xs text-red-600" role="alert">
          {validation?.message}
        </p>
      ) : null}
      {onClear ? (
        <button
          type="button"
          className="text-xs font-medium text-neutral-600 underline-offset-2 hover:underline"
          onClick={onClear}
          disabled={disabled}
        >
          Wyczyść treść
        </button>
      ) : null}
    </div>
  );
}



================================================
FILE: src/components/generate/GenerateView.tsx
================================================
import {
  useCallback,
  useEffect,
  useMemo,
  useState,
  type FormEvent,
} from "react";
import type { DeckCreateCommand, GenerateCardsCommand } from "@/types";
import type {
  DeckOptionVm,
  GenerateLimitsVm,
  GenerateRequestStateVm,
  GenerateValidationVm,
} from "@/lib/viewmodels/generate.vm";
import { useGenerateCards } from "@/components/hooks/useGenerateCards";
import { useGenerateDraft } from "@/components/hooks/useGenerateDraft";
import { useDecks } from "@/components/hooks/useDecks";
import { createDeck } from "@/lib/services/decks-client.service";
import { CreateDeckModal } from "@/components/generate/CreateDeckModal";
import { DeckPicker } from "@/components/generate/DeckPicker";
import { GenerateProgressPanel } from "@/components/generate/GenerateProgressPanel";
import { GenerateSubmitButton } from "@/components/generate/GenerateSubmitButton";
import { GenerateTextInput } from "@/components/generate/GenerateTextInput";
import { LimitBanner } from "@/components/generate/LimitBanner";

type GenerateViewProps = {
  initialContent?: string;
  initialDeckId?: string | null;
};

const MIN_CONTENT_LENGTH = 50;
const MAX_CONTENT_LENGTH = 100000;
const DRAFT_STORAGE_KEY = "generate:draft";
const uuidPattern =
  /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

export function GenerateView({
  initialContent = "",
  initialDeckId = null,
}: GenerateViewProps) {
  const { value: content, setValue: setContent, clear: clearDraft } =
    useGenerateDraft(DRAFT_STORAGE_KEY, initialContent);
  const [deckId, setDeckId] = useState<string | null>(initialDeckId);
  const [touchedContent, setTouchedContent] = useState(false);
  const [limits, setLimits] = useState<GenerateLimitsVm>({
    isGenerationBlocked: false,
  });
  const { decks, status: decksStatus, error: decksError, addDeck } = useDecks();
  const [isCreateDeckOpen, setIsCreateDeckOpen] = useState(false);
  const [createDeckError, setCreateDeckError] = useState<string | null>(null);
  const [isCreatingDeck, setIsCreatingDeck] = useState(false);
  const [isDeckLimitReached, setIsDeckLimitReached] = useState(false);
  const { mutate, status, data, error, reset } = useGenerateCards();

  const requestState = useMemo<GenerateRequestStateVm>(() => {
    if (data) {
      return {
        status,
        lastResponse: {
          sourceId: data.source_id,
          remainingGenerations: data.remaining_generations,
        },
      };
    }

    return { status };
  }, [data, status]);

  const validation = useMemo<GenerateValidationVm>(() => {
    if (content.length < MIN_CONTENT_LENGTH) {
      return {
        content: {
          code: "too_short",
          message: "Za krótki tekst. Dodaj więcej treści.",
        },
      };
    }

    if (content.length > MAX_CONTENT_LENGTH) {
      return {
        content: {
          code: "too_long",
          message: "Za długi tekst. Skróć treść wejściową.",
        },
      };
    }

    return { content: null };
  }, [content]);

  const deckOptions = useMemo<DeckOptionVm[]>(() => {
    const baseOption: DeckOptionVm = {
      value: null,
      label: "Bez decka (Oczekujące)",
    };

    return [
      baseOption,
      ...decks.map((deck) => ({
        value: deck.id,
        label: deck.name,
        description: deck.description ?? undefined,
      })),
    ];
  }, [decks]);

  const deckHelperText = useMemo(() => {
    if (decksStatus === "loading") {
      return "Ładuję decki...";
    }
    if (decksStatus === "error") {
      return decksError ?? "Nie udało się pobrać decków.";
    }
    if (isDeckLimitReached) {
      return "Osiągnięto limit decków. Usuń istniejący, aby dodać nowy.";
    }
    if (decks.length === 0) {
      return "Brak decków. Możesz utworzyć pierwszy.";
    }
    return undefined;
  }, [decks, decksError, decksStatus, isDeckLimitReached]);

  const isContentInvalid =
    content.length < MIN_CONTENT_LENGTH || content.length > MAX_CONTENT_LENGTH;
  const isSubmitDisabled =
    status === "loading" ||
    isContentInvalid ||
    limits.isGenerationBlocked;

  const handleContentChange = useCallback((next: string) => {
    setContent(next);
  }, []);

  const handleContentBlur = useCallback(() => {
    setTouchedContent(true);
  }, []);

  const handleClearContent = useCallback(() => {
    clearDraft();
    setTouchedContent(false);
  }, [clearDraft]);

  const handleDeckChange = useCallback((nextDeckId: string | null) => {
    setDeckId(nextDeckId);
  }, []);

  const handleCreateDeckClick = useCallback(() => {
    setIsCreateDeckOpen(true);
  }, []);

  const handleCreateDeckSubmit = useCallback(
    async (command: DeckCreateCommand) => {
      setIsCreatingDeck(true);
      setCreateDeckError(null);
      try {
        const deck = await createDeck(command);
        addDeck(deck);
        setDeckId(deck.id);
        setIsCreateDeckOpen(false);
        setIsDeckLimitReached(false);
      } catch (err) {
        const apiError = err as { status?: number };
        if (apiError.status === 429) {
          setCreateDeckError("Osiągnięto limit decków. Usuń istniejący lub spróbuj później.");
          setIsDeckLimitReached(true);
        } else {
          setCreateDeckError("Nie udało się utworzyć decka. Spróbuj ponownie.");
        }
      } finally {
        setIsCreatingDeck(false);
      }
    },
    [addDeck],
  );

  const handleCreateDeckOpenChange = useCallback((open: boolean) => {
    setIsCreateDeckOpen(open);
    if (!open) {
      setCreateDeckError(null);
    }
  }, []);

  const handleSubmit = useCallback(
    (event: FormEvent<HTMLFormElement>) => {
      event.preventDefault();
      setTouchedContent(true);

      if (isSubmitDisabled) {
        return;
      }

      const command: GenerateCardsCommand = {
        content,
      };

      if (deckId && uuidPattern.test(deckId)) {
        command.deck_id = deckId;
      }

      mutate(command);
    },
    [content, deckId, isSubmitDisabled, mutate],
  );

  const handleRetry = useCallback(() => {
    reset();
  }, [reset]);

  useEffect(() => {
    if (!data) {
      return;
    }

    setLimits({
      remainingGenerations: data.remaining_generations,
      isGenerationBlocked: data.remaining_generations <= 0,
      reason: data.remaining_generations <= 0 ? "limit_reached" : undefined,
    });
  }, [data]);

  useEffect(() => {
    if (!error?.status || error.status !== 429) {
      return;
    }

    setLimits({
      remainingGenerations: 0,
      isGenerationBlocked: true,
      reason: "limit_reached",
    });
  }, [error]);

  useEffect(() => {
    if (!data || typeof window === "undefined") {
      return;
    }

    window.location.assign(`/generate/results?source_id=${data.source_id}`);
  }, [data]);

  const showValidationError = touchedContent && Boolean(validation.content);
  const limitError = error?.status === 429 ? error : null;
  const canRetry = error?.status !== 429;

  return (
    <main className="mx-auto flex w-full max-w-5xl flex-col gap-6 px-4 py-10">
      <header className="space-y-2">
        <p className="text-xs uppercase tracking-[0.2em] text-neutral-500">
          Generowanie fiszek
        </p>
        <h1 className="text-3xl font-semibold text-neutral-900">
          Generuj fiszki
        </h1>
        <p className="text-sm text-neutral-600">
          Wklej tekst źródłowy, wybierz deck i uruchom generację.
        </p>
      </header>

      <LimitBanner limits={limits} error={limitError} />

      <div className="grid gap-6 lg:grid-cols-[minmax(0,1fr)_320px]">
        <form className="space-y-6" onSubmit={handleSubmit}>
          <GenerateTextInput
            value={content}
            minLength={MIN_CONTENT_LENGTH}
            maxLength={MAX_CONTENT_LENGTH}
            onContentChange={handleContentChange}
            onClear={handleClearContent}
            onBlur={handleContentBlur}
            disabled={status === "loading"}
            validation={
              showValidationError
                ? { state: "error", message: validation.content?.message }
                : { state: "idle" }
            }
          />
          <DeckPicker
            value={deckId}
            options={deckOptions}
            disabled={status === "loading" || decksStatus === "loading"}
            helperText={deckHelperText}
            createDisabled={isDeckLimitReached}
            onChange={handleDeckChange}
            onCreateDeck={handleCreateDeckClick}
          />
          <GenerateSubmitButton
            disabled={isSubmitDisabled}
            loading={status === "loading"}
          />
        </form>

        <GenerateProgressPanel
          state={requestState}
          error={error}
          onRetry={canRetry ? handleRetry : undefined}
        />
      </div>

      <CreateDeckModal
        open={isCreateDeckOpen}
        onOpenChange={handleCreateDeckOpenChange}
        onSubmit={handleCreateDeckSubmit}
        isSubmitting={isCreatingDeck}
        errorMessage={createDeckError}
      />
    </main>
  );
}



================================================
FILE: src/components/generate/LimitBanner.tsx
================================================
import type {
  GenerateApiErrorVm,
  GenerateLimitsVm,
} from "@/lib/viewmodels/generate.vm";

type LimitBannerProps = {
  limits: GenerateLimitsVm;
  error?: GenerateApiErrorVm | null;
  onDismiss?: () => void;
};

export function LimitBanner({ limits, error, onDismiss }: LimitBannerProps) {
  const showBanner = limits.isGenerationBlocked || Boolean(error);

  if (!showBanner) {
    return null;
  }

  const title = limits.isGenerationBlocked
    ? "Limit generacji został wykorzystany"
    : "Nie można teraz generować";

  const description =
    error?.message ??
    (limits.remainingGenerations === 0
      ? "Wróć później lub poczekaj na odnowienie limitu."
      : "Spróbuj ponownie za jakiś czas.");

  return (
    <section
      className="rounded-md border border-amber-200 bg-amber-50 p-4 text-sm text-amber-800"
      role="alert"
    >
      <div className="flex items-start justify-between gap-4">
        <div className="space-y-1">
          <p className="font-medium">{title}</p>
          <p className="text-xs text-amber-700">{description}</p>
        </div>
        {onDismiss ? (
          <button
            type="button"
            className="text-xs font-medium text-amber-800 underline-offset-2 hover:underline"
            onClick={onDismiss}
          >
            Zamknij
          </button>
        ) : null}
      </div>
    </section>
  );
}



================================================
FILE: src/components/hooks/useDecks.ts
================================================
import { useCallback, useEffect, useState } from "react";
import type { DeckDto, ListDecksResponseDto } from "@/types";
import { getDecks } from "@/lib/services/decks-client.service";

type DecksStatus = "idle" | "loading" | "success" | "error";

export function useDecks() {
  const [decks, setDecks] = useState<DeckDto[]>([]);
  const [status, setStatus] = useState<DecksStatus>("idle");
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    let isMounted = true;
    const load = async () => {
      setStatus("loading");
      setError(null);
      try {
        const response: ListDecksResponseDto = await getDecks({ page: 1, limit: 50 });
        if (!isMounted) {
          return;
        }
        setDecks(response.data ?? []);
        setStatus("success");
      } catch {
        if (!isMounted) {
          return;
        }
        setStatus("error");
        setError("Nie udało się pobrać listy decków.");
      }
    };

    load();
    return () => {
      isMounted = false;
    };
  }, []);

  const addDeck = useCallback((deck: DeckDto) => {
    setDecks((prev) => [deck, ...prev]);
  }, []);

  return { decks, status, error, addDeck };
}



================================================
FILE: src/components/hooks/useGenerateCards.ts
================================================
import { useCallback, useState } from "react";
import type { GenerateCardsCommand, GenerateCardsResponseDto } from "@/types";
import type {
  GenerateApiErrorVm,
  GenerateRequestStatus,
} from "@/lib/viewmodels/generate.vm";
import { postGenerateCards } from "@/lib/services/generate-client.service";

type GenerateClientError = {
  status?: number;
  code?: string;
  message?: string;
  details?: unknown;
};

function mapGenerateError(error: GenerateClientError): GenerateApiErrorVm {
  const status = error.status;
  const code = error.code;

  if (status === 429) {
    return {
      status,
      code,
      message: "Wyczerpano dzienny limit generacji. Spróbuj jutro.",
      debugDetails: import.meta.env.DEV ? error.details : undefined,
    };
  }

  if (status === 401) {
    return {
      status,
      code,
      message: "Zaloguj się, aby kontynuować generowanie.",
      debugDetails: import.meta.env.DEV ? error.details : undefined,
    };
  }

  if (status === 400) {
    return {
      status,
      code,
      message: "Niepoprawne dane formularza. Sprawdź treść wejściową.",
      debugDetails: import.meta.env.DEV ? error.details : undefined,
    };
  }

  if (status && status >= 500) {
    return {
      status,
      code,
      message: "Coś poszło nie tak. Spróbuj ponownie.",
      debugDetails: import.meta.env.DEV ? error.details : undefined,
    };
  }

  return {
    status,
    code,
    message: "Nie udało się wykonać żądania. Sprawdź połączenie.",
    debugDetails: import.meta.env.DEV ? error.details : undefined,
  };
}

export function useGenerateCards() {
  const [status, setStatus] = useState<GenerateRequestStatus>("idle");
  const [data, setData] = useState<GenerateCardsResponseDto | null>(null);
  const [error, setError] = useState<GenerateApiErrorVm | null>(null);

  const mutate = useCallback(async (command: GenerateCardsCommand) => {
    setStatus("loading");
    setError(null);

    try {
      const response = await postGenerateCards(command);
      setData(response);
      setStatus("success");
      return response;
    } catch (err) {
      const apiError = err as GenerateClientError;
      setError(mapGenerateError(apiError));
      setStatus("error");
      return null;
    }
  }, []);

  const reset = useCallback(() => {
    setStatus("idle");
    setError(null);
  }, []);

  return { mutate, status, data, error, reset };
}



================================================
FILE: src/components/hooks/useGenerateDraft.ts
================================================
import { useCallback, useEffect, useRef, useState } from "react";

const DEFAULT_DEBOUNCE_MS = 400;

export function useGenerateDraft(storageKey: string, initialValue = "") {
  const [value, setValue] = useState(initialValue);
  const timeoutRef = useRef<number | null>(null);

  useEffect(() => {
    if (typeof window === "undefined") {
      return;
    }

    const stored = window.localStorage.getItem(storageKey);
    if (stored !== null) {
      setValue(stored);
      return;
    }

    if (initialValue) {
      setValue(initialValue);
    }
  }, [storageKey, initialValue]);

  useEffect(() => {
    if (typeof window === "undefined") {
      return;
    }

    if (timeoutRef.current) {
      window.clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = window.setTimeout(() => {
      window.localStorage.setItem(storageKey, value);
    }, DEFAULT_DEBOUNCE_MS);

    return () => {
      if (timeoutRef.current) {
        window.clearTimeout(timeoutRef.current);
      }
    };
  }, [storageKey, value]);

  const clear = useCallback(() => {
    if (typeof window !== "undefined") {
      window.localStorage.removeItem(storageKey);
    }
    setValue("");
  }, [storageKey]);

  return { value, setValue, clear };
}



================================================
FILE: src/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: src/db/database.types.ts
================================================
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  graphql_public: {
    Tables: {
      [_ in never]: never
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      graphql: {
        Args: {
          extensions?: Json
          operationName?: string
          query?: string
          variables?: Json
        }
        Returns: Json
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
  public: {
    Tables: {
      cards: {
        Row: {
          answer: string
          context: string | null
          created_at: string | null
          deck_id: string | null
          difficulty: number | null
          external_metadata: Json | null
          id: string
          is_manual_override: boolean | null
          last_synced_at: string | null
          quality_status: string | null
          question: string
          source_id: string | null
          tags: string[] | null
          updated_at: string | null
          user_id: string
        }
        Insert: {
          answer: string
          context?: string | null
          created_at?: string | null
          deck_id?: string | null
          difficulty?: number | null
          external_metadata?: Json | null
          id?: string
          is_manual_override?: boolean | null
          last_synced_at?: string | null
          quality_status?: string | null
          question: string
          source_id?: string | null
          tags?: string[] | null
          updated_at?: string | null
          user_id: string
        }
        Update: {
          answer?: string
          context?: string | null
          created_at?: string | null
          deck_id?: string | null
          difficulty?: number | null
          external_metadata?: Json | null
          id?: string
          is_manual_override?: boolean | null
          last_synced_at?: string | null
          quality_status?: string | null
          question?: string
          source_id?: string | null
          tags?: string[] | null
          updated_at?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "cards_deck_id_fkey"
            columns: ["deck_id"]
            isOneToOne: false
            referencedRelation: "decks"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "cards_source_id_fkey"
            columns: ["source_id"]
            isOneToOne: false
            referencedRelation: "sources"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "cards_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      decks: {
        Row: {
          created_at: string | null
          description: string | null
          id: string
          name: string
          user_id: string
        }
        Insert: {
          created_at?: string | null
          description?: string | null
          id?: string
          name: string
          user_id: string
        }
        Update: {
          created_at?: string | null
          description?: string | null
          id?: string
          name?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "decks_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      kpi_events: {
        Row: {
          created_at: string | null
          event_type: string
          id: number
          metadata: Json | null
          user_id: string
        }
        Insert: {
          created_at?: string | null
          event_type: string
          id?: never
          metadata?: Json | null
          user_id: string
        }
        Update: {
          created_at?: string | null
          event_type?: string
          id?: never
          metadata?: Json | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "kpi_events_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      profiles: {
        Row: {
          account_role: string
          created_at: string | null
          email: string
          id: string
          last_active_at: string | null
        }
        Insert: {
          account_role?: string
          created_at?: string | null
          email: string
          id: string
          last_active_at?: string | null
        }
        Update: {
          account_role?: string
          created_at?: string | null
          email?: string
          id?: string
          last_active_at?: string | null
        }
        Relationships: []
      }
      sources: {
        Row: {
          character_count: number
          content: string
          created_at: string | null
          id: string
          title: string
          user_id: string
        }
        Insert: {
          character_count: number
          content: string
          created_at?: string | null
          id?: string
          title: string
          user_id: string
        }
        Update: {
          character_count?: number
          content?: string
          created_at?: string | null
          id?: string
          title?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "sources_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      user_usage_stats: {
        Row: {
          date: string
          generation_count: number | null
          user_id: string
        }
        Insert: {
          date?: string
          generation_count?: number | null
          user_id: string
        }
        Update: {
          date?: string
          generation_count?: number | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "user_usage_stats_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      increment_daily_generation: {
        Args: {
          p_user_id: string
          p_daily_limit: number
        }
        Returns: number
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  graphql_public: {
    Enums: {},
  },
  public: {
    Enums: {},
  },
} as const




================================================
FILE: src/db/supabase.client.ts
================================================
import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient as SupabaseJsClient } from '@supabase/supabase-js';

import type { Database } from '../db/database.types.ts';

// Server-side client (used in middleware -> context.locals.supabase for API routes).
// Prefer service role to bypass RLS for backend-only operations (limits, KPI, etc.).
const supabaseUrl =
  import.meta.env.SUPABASE_URL ??
  process.env.SUPABASE_URL ??
  import.meta.env.PUBLIC_SUPABASE_URL ??
  process.env.PUBLIC_SUPABASE_URL;
const supabaseKey =
  import.meta.env.SUPABASE_SERVICE_ROLE_KEY ??
  process.env.SUPABASE_SERVICE_ROLE_KEY ??
  import.meta.env.SUPABASE_KEY ??
  process.env.SUPABASE_KEY ??
  import.meta.env.PUBLIC_SUPABASE_ANON_KEY ??
  process.env.PUBLIC_SUPABASE_ANON_KEY;

export const supabaseClient = createClient<Database>(supabaseUrl, supabaseKey);

// Project rule: use SupabaseClient type from this module, not from '@supabase/supabase-js'.
export type SupabaseClient = SupabaseJsClient<Database>;

// Temporary default user for early-stage API development (auth will be added later).
// NOTE: Must be a valid UUID of an existing user/profile in the DB to satisfy FK constraints.
export const DEFAULT_USER_ID = import.meta.env.DEFAULT_USER_ID ?? process.env.DEFAULT_USER_ID;



================================================
FILE: src/layouts/Layout.astro
================================================
---
import "../styles/global.css";

interface Props {
  title?: string;
}

const { title = "10x Astro Starter" } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
  </head>
  <body>
    <slot />
  </body>
</html>

<style>
  html,
  body {
    margin: 0;
    width: 100%;
    height: 100%;
  }
</style>



================================================
FILE: src/lib/openrouter.service.ts
================================================
export type OpenRouterChatMessage =
  | { role: "system" | "user" | "assistant"; content: string; name?: string }
  | { role: "tool"; content: string; tool_call_id: string; name?: string };

export type OpenRouterModelParams = {
  temperature?: number;
  max_tokens?: number;
  top_p?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  seed?: number;
  stop?: string | string[];
};

export type SendChatCompletionInput = {
  userId?: string;
  model?: string;
  messages: OpenRouterChatMessage[];
  params?: OpenRouterModelParams;
  response_format?: unknown;
};

export type SendChatCompletionResult = {
  id: string;
  model: string;
  content: string;
  usage?: {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
    cost?: number;
  };
  requestId?: string;
};

export type OpenRouterJsonSchemaResponseFormat = {
  type: "json_schema";
  json_schema: {
    name: string;
    strict: true;
    schema: Record<string, unknown>;
  };
};

export type OpenRouterStructuredSchema<T> = {
  response_format: OpenRouterJsonSchemaResponseFormat;
  /**
   * Runtime validation and parsing hook.
   * Keep it deterministic and side-effect free.
   */
  parse: (value: unknown) => T;
};

export type OpenRouterServiceConfig = {
  apiKey: string;
  baseUrl?: string; // default: https://openrouter.ai/api/v1
  appReferer?: string; // HTTP-Referer
  appTitle?: string; // X-Title
  defaultModel: string;
  requestTimeoutMs: number;
  maxRetries: number;
  /**
   * Cost/safety control: allow only explicitly approved models.
   * If provided, any model outside the list will be rejected.
   */
  allowedModels?: readonly string[];
  /**
   * Input guardrails (characters, not tokens).
   */
  maxMessages?: number; // default: 50
  maxMessageChars?: number; // default: 20_000
};

export type OpenRouterLogger = {
  info: (msg: string, meta?: Record<string, unknown>) => void;
  warn: (msg: string, meta?: Record<string, unknown>) => void;
  error: (msg: string, meta?: Record<string, unknown>) => void;
};

export type OpenRouterUsageTracker = {
  track: (event: {
    userId?: string;
    model?: string;
    promptTokens?: number;
    completionTokens?: number;
    totalTokens?: number;
    cost?: number;
    requestId?: string;
  }) => Promise<void> | void;
};

export type OpenRouterServiceDeps = {
  fetchImpl?: typeof fetch;
  now?: () => number;
  sleep?: (ms: number) => Promise<void>;
  logger?: OpenRouterLogger;
  usageTracker?: OpenRouterUsageTracker;
};

type OpenRouterErrorCode =
  | "openrouter_config_error"
  | "openrouter_input_validation_error"
  | "openrouter_auth_error"
  | "openrouter_rate_limit"
  | "openrouter_upstream_error"
  | "openrouter_timeout"
  | "openrouter_unsupported_feature"
  | "openrouter_response_parse_error"
  | "openrouter_schema_validation_error";

class OpenRouterError extends Error {
  readonly code: OpenRouterErrorCode;
  readonly status: number;
  readonly meta?: Record<string, unknown>;

  constructor(params: {
    code: OpenRouterErrorCode;
    status: number;
    message: string;
    meta?: Record<string, unknown>;
    cause?: unknown;
  }) {
    super(params.message);
    this.code = params.code;
    this.status = params.status;
    this.meta = params.meta;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    (this as any).cause = params.cause;
  }
}

export class OpenRouterConfigError extends OpenRouterError {
  constructor(message: string, meta?: Record<string, unknown>, cause?: unknown) {
    super({ code: "openrouter_config_error", status: 500, message, meta, cause });
  }
}

export class OpenRouterInputValidationError extends OpenRouterError {
  constructor(message: string, meta?: Record<string, unknown>, cause?: unknown) {
    super({ code: "openrouter_input_validation_error", status: 400, message, meta, cause });
  }
}

export class OpenRouterAuthError extends OpenRouterError {
  constructor(status: 401 | 403, message: string, meta?: Record<string, unknown>, cause?: unknown) {
    super({ code: "openrouter_auth_error", status, message, meta, cause });
  }
}

export class OpenRouterRateLimitError extends OpenRouterError {
  constructor(message: string, meta?: Record<string, unknown>, cause?: unknown) {
    super({ code: "openrouter_rate_limit", status: 429, message, meta, cause });
  }
}

export class OpenRouterUpstreamError extends OpenRouterError {
  constructor(status: number, message: string, meta?: Record<string, unknown>, cause?: unknown) {
    super({ code: "openrouter_upstream_error", status, message, meta, cause });
  }
}

export class OpenRouterTimeoutError extends OpenRouterError {
  constructor(message: string, meta?: Record<string, unknown>, cause?: unknown) {
    super({ code: "openrouter_timeout", status: 408, message, meta, cause });
  }
}

export class OpenRouterUnsupportedFeatureError extends OpenRouterError {
  constructor(message: string, meta?: Record<string, unknown>, cause?: unknown) {
    super({ code: "openrouter_unsupported_feature", status: 502, message, meta, cause });
  }
}

export class OpenRouterResponseParseError extends OpenRouterError {
  constructor(message: string, meta?: Record<string, unknown>, cause?: unknown) {
    super({ code: "openrouter_response_parse_error", status: 500, message, meta, cause });
  }
}

export class OpenRouterSchemaValidationError extends OpenRouterError {
  constructor(message: string, meta?: Record<string, unknown>, cause?: unknown) {
    super({ code: "openrouter_schema_validation_error", status: 500, message, meta, cause });
  }
}

type OpenRouterNonStreamingResponse = {
  id?: string;
  model?: string;
  choices?: Array<{
    message?: { content?: string };
    finish_reason?: string;
  }>;
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
    cost?: number;
  };
  error?: unknown;
};

function safeTrimTrailingSlash(url: string): string {
  return url.endsWith("/") ? url.slice(0, -1) : url;
}

function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === "object" && value !== null;
}

function getErrorMessage(value: unknown): string | undefined {
  if (typeof value === "string") return value;
  if (!isObject(value)) return undefined;
  const msg = value["message"];
  return typeof msg === "string" ? msg : undefined;
}

function defaultSleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function jitteredBackoffMs(attempt: number): number {
  // attempt: 1..N
  const base = 250;
  const capped = Math.min(4_000, base * 2 ** (attempt - 1));
  const jitter = Math.floor(Math.random() * 200);
  return capped + jitter;
}

function maskUserId(userId?: string): string | undefined {
  if (!userId) return undefined;
  if (userId.length <= 6) return "***";
  return `${userId.slice(0, 3)}***${userId.slice(-2)}`;
}

export class OpenRouterService {
  public readonly defaultModel: string;
  public readonly baseUrl: string;

  private readonly cfg: OpenRouterServiceConfig;
  private readonly fetchImpl: typeof fetch;
  private readonly now: () => number;
  private readonly sleep: (ms: number) => Promise<void>;
  private readonly logger?: OpenRouterLogger;
  private readonly usageTracker?: OpenRouterUsageTracker;
  private readonly endpointUrl: string;

  constructor(cfg: OpenRouterServiceConfig, deps: OpenRouterServiceDeps = {}) {
    if (!cfg.apiKey || !cfg.apiKey.trim()) {
      throw new OpenRouterConfigError("OpenRouter API key is not configured.");
    }
    if (!cfg.defaultModel || !cfg.defaultModel.trim()) {
      throw new OpenRouterConfigError("OpenRouter default model is not configured.");
    }
    if (!Number.isFinite(cfg.requestTimeoutMs) || cfg.requestTimeoutMs <= 0) {
      throw new OpenRouterConfigError("OpenRouter requestTimeoutMs must be a positive number.");
    }
    if (!Number.isFinite(cfg.maxRetries) || cfg.maxRetries < 0) {
      throw new OpenRouterConfigError("OpenRouter maxRetries must be >= 0.");
    }

    this.cfg = cfg;
    this.defaultModel = cfg.defaultModel;
    this.baseUrl = safeTrimTrailingSlash(cfg.baseUrl ?? "https://openrouter.ai/api/v1");
    this.fetchImpl = deps.fetchImpl ?? globalThis.fetch;
    this.now = deps.now ?? (() => Date.now());
    this.sleep = deps.sleep ?? defaultSleep;
    this.logger = deps.logger;
    this.usageTracker = deps.usageTracker;
    this.endpointUrl = `${this.baseUrl}/chat/completions`;
  }

  public async sendChatCompletion(input: SendChatCompletionInput): Promise<SendChatCompletionResult> {
    this.assertInputSafe(input);

    const model = this.pickModel(input.model);
    const body = this.buildBody({
      userId: input.userId,
      model,
      messages: input.messages,
      params: input.params,
      response_format: input.response_format,
    });

    const json = await this.requestWithRetry({
      body,
      userId: input.userId,
      model,
      expectStructured: false,
    });

    return await this.parseNonStreamingResponse({
      json,
      userId: input.userId,
      fallbackModel: model,
    });
  }

  public async sendChatCompletionStructured<T>(
    input: Omit<SendChatCompletionInput, "response_format">,
    schema: OpenRouterStructuredSchema<T>,
  ): Promise<{ raw: SendChatCompletionResult; data: T }> {
    this.assertInputSafe(input);

    const model = this.pickModel(input.model);
    const body = this.buildBody({
      userId: input.userId,
      model,
      messages: input.messages,
      params: input.params,
      response_format: schema.response_format,
    });

    const json = await this.requestWithRetry({
      body,
      userId: input.userId,
      model,
      expectStructured: true,
    });

    const raw = await this.parseNonStreamingResponse({
      json,
      userId: input.userId,
      fallbackModel: model,
    });

    const data = this.parseStructuredContent(schema, raw.content);
    return { raw, data };
  }

  private buildHeaders(): HeadersInit {
    const headers: Record<string, string> = {
      Authorization: `Bearer ${this.cfg.apiKey}`,
      "Content-Type": "application/json",
    };

    // Optional attribution headers (not secrets).
    if (this.cfg.appReferer) headers["HTTP-Referer"] = this.cfg.appReferer;
    if (this.cfg.appTitle) headers["X-Title"] = this.cfg.appTitle;

    return headers;
  }

  private assertInputSafe(input: Pick<SendChatCompletionInput, "messages" | "userId" | "model">): void {
    if (!Array.isArray(input.messages) || input.messages.length === 0) {
      throw new OpenRouterInputValidationError("messages is required.");
    }

    const maxMessages = this.cfg.maxMessages ?? 50;
    if (input.messages.length > maxMessages) {
      throw new OpenRouterInputValidationError("Too many messages.", {
        maxMessages,
        got: input.messages.length,
      });
    }

    const maxMessageChars = this.cfg.maxMessageChars ?? 20_000;
    for (const msg of input.messages) {
      if (!msg || typeof (msg as any).role !== "string" || typeof (msg as any).content !== "string") {
        throw new OpenRouterInputValidationError("Invalid message shape.");
      }
      if (msg.content.length > maxMessageChars) {
        throw new OpenRouterInputValidationError("Message content is too long.", {
          maxMessageChars,
          got: msg.content.length,
        });
      }
    }

    if (this.cfg.allowedModels && input.model && !this.cfg.allowedModels.includes(input.model)) {
      throw new OpenRouterInputValidationError("Model is not allowed.", {
        model: input.model,
      });
    }
  }

  private pickModel(model?: string): string {
    const picked = (model ?? this.cfg.defaultModel).trim();
    if (!picked) {
      throw new OpenRouterInputValidationError("Model is required.");
    }
    if (this.cfg.allowedModels && !this.cfg.allowedModels.includes(picked)) {
      throw new OpenRouterInputValidationError("Model is not allowed.", { model: picked });
    }
    return picked;
  }

  private buildBody(params: {
    userId?: string;
    model: string;
    messages: OpenRouterChatMessage[];
    params?: OpenRouterModelParams;
    response_format?: unknown;
  }): Record<string, unknown> {
    const { userId, model, messages, response_format } = params;
    const mp = params.params ?? {};

    // OpenRouter (OpenAI-compatible) expects model params at top-level.
    return {
      model,
      messages,
      response_format,
      user: userId,
      ...mp,
    };
  }

  private async withTimeout<T>(fn: (signal: AbortSignal) => Promise<T>, ms: number): Promise<T> {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), ms);
    try {
      return await fn(controller.signal);
    } finally {
      clearTimeout(timeout);
    }
  }

  private shouldRetry(status: number): boolean {
    if (status === 429) return true;
    if (status >= 500 && status <= 599) return true;
    return false;
  }

  private async requestWithRetry(params: {
    body: Record<string, unknown>;
    userId?: string;
    model: string;
    expectStructured: boolean;
  }): Promise<OpenRouterNonStreamingResponse> {
    const { body, userId, model, expectStructured } = params;
    const startedAt = this.now();

    const maxRetries = this.cfg.maxRetries;
    let lastErr: unknown;

    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      const attemptNo = attempt + 1;
      try {
        const res = await this.withTimeout(
          (signal) =>
            this.fetchImpl(this.endpointUrl, {
              method: "POST",
              headers: this.buildHeaders(),
              body: JSON.stringify(body),
              signal,
            }),
          this.cfg.requestTimeoutMs,
        );

        const requestId = res.headers.get("x-request-id") ?? res.headers.get("x-openrouter-request-id") ?? undefined;

        if (!res.ok) {
          const status = res.status;
          const errPayload = await this.safeReadJson(res);
          const mapped = this.toDomainError({
            status,
            payload: errPayload,
            requestId,
            model,
            expectStructured,
          });

          if (attempt < maxRetries && this.shouldRetry(status)) {
            this.logger?.warn("OpenRouter request failed (will retry).", {
              status,
              code: mapped.code,
              model,
              attempt: attemptNo,
              maxRetries,
              requestId,
              userId: maskUserId(userId),
            });
            const delay = jitteredBackoffMs(attemptNo);
            await this.sleep(delay);
            continue;
          }

          throw mapped;
        }

        const json = (await res.json()) as OpenRouterNonStreamingResponse;
        // attach requestId for downstream usage tracking / logs (without mutating returned content)
        if (requestId && isObject(json)) {
          (json as any).__requestId = requestId;
        }

        this.logger?.info("OpenRouter request succeeded.", {
          model,
          attempt: attemptNo,
          requestId,
          ms: this.now() - startedAt,
          userId: maskUserId(userId),
        });

        return json;
      } catch (err) {
        lastErr = err;
        if (err instanceof OpenRouterError) {
          // already mapped (do not retry here - mapping above handles retry-worthy HTTP codes)
          throw err;
        }

        if (this.isAbortError(err)) {
          throw new OpenRouterTimeoutError("OpenRouter request timed out.", { model }, err);
        }

        // Network/transport failure: retry best-effort (same policy as 5xx)
        if (attempt < maxRetries) {
          this.logger?.warn("OpenRouter transport error (will retry).", {
            model,
            attempt: attemptNo,
            maxRetries,
            userId: maskUserId(userId),
          });
          const delay = jitteredBackoffMs(attemptNo);
          await this.sleep(delay);
          continue;
        }

        throw new OpenRouterUpstreamError(503, "OpenRouter request failed (transport error).", { model }, err);
      }
    }

    throw new OpenRouterUpstreamError(503, "OpenRouter request failed after retries.", { model }, lastErr);
  }

  private async safeReadJson(res: Response): Promise<unknown> {
    try {
      return await res.json();
    } catch {
      return undefined;
    }
  }

  private isAbortError(err: unknown): boolean {
    if (!err) return false;
    if (err instanceof DOMException && err.name === "AbortError") return true;
    if (isObject(err) && typeof err["name"] === "string" && err["name"] === "AbortError") return true;
    return false;
  }

  private async parseNonStreamingResponse(params: {
    json: OpenRouterNonStreamingResponse;
    userId?: string;
    fallbackModel: string;
  }): Promise<SendChatCompletionResult> {
    const { json, userId, fallbackModel } = params;

    const requestId =
      isObject(json) && typeof (json as any).__requestId === "string" ? ((json as any).__requestId as string) : undefined;

    const id = typeof json.id === "string" && json.id.trim() ? json.id : "unknown";
    const model = typeof json.model === "string" && json.model.trim() ? json.model : fallbackModel;
    const content = json.choices?.[0]?.message?.content;

    if (!content || typeof content !== "string") {
      throw new OpenRouterResponseParseError("OpenRouter returned empty response.", {
        id,
        model,
        requestId,
      });
    }

    const usageRaw = json.usage;
    const usage =
      usageRaw &&
      typeof usageRaw.prompt_tokens === "number" &&
      typeof usageRaw.completion_tokens === "number" &&
      typeof usageRaw.total_tokens === "number"
        ? {
            prompt_tokens: usageRaw.prompt_tokens,
            completion_tokens: usageRaw.completion_tokens,
            total_tokens: usageRaw.total_tokens,
            cost: typeof usageRaw.cost === "number" ? usageRaw.cost : undefined,
          }
        : undefined;

    if (usage) {
      // Must never block the main flow.
      try {
        await this.usageTracker?.track({
          userId,
          model,
          promptTokens: usage.prompt_tokens,
          completionTokens: usage.completion_tokens,
          totalTokens: usage.total_tokens,
          cost: usage.cost,
          requestId,
        });
      } catch (e) {
        this.logger?.warn("OpenRouter usageTracker.track failed.", { model, requestId });
      }
    }

    return { id, model, content, usage, requestId };
  }

  private parseStructuredContent<T>(schema: OpenRouterStructuredSchema<T>, content: string): T {
    let parsed: unknown;
    try {
      parsed = JSON.parse(content);
    } catch (err) {
      throw new OpenRouterResponseParseError("OpenRouter structured output is not valid JSON.", undefined, err);
    }

    try {
      return schema.parse(parsed);
    } catch (err) {
      throw new OpenRouterSchemaValidationError("OpenRouter structured output does not match schema.", undefined, err);
    }
  }

  private toDomainError(params: {
    status: number;
    payload: unknown;
    requestId?: string;
    model: string;
    expectStructured: boolean;
  }): OpenRouterError {
    const { status, payload, requestId, model, expectStructured } = params;

    // Best-effort extraction of OpenRouter error message
    let message =
      (isObject(payload) && getErrorMessage(payload["error"])) ||
      (isObject(payload) && getErrorMessage(payload)) ||
      undefined;

    if (!message && isObject(payload) && isObject(payload["error"])) {
      message = getErrorMessage(payload["error"]);
    }

    const meta: Record<string, unknown> = {
      status,
      model,
      requestId,
      // Helps debugging provider-specific failures (dev tooling can surface this).
      payload,
    };

    if (status === 401 || status === 403) {
      return new OpenRouterAuthError(status, "OpenRouter authorization failed.", meta);
    }
    if (status === 429) {
      return new OpenRouterRateLimitError("OpenRouter rate limit exceeded.", meta);
    }

    // Some providers/models may reject structured outputs. Keep mapping conservative.
    if (expectStructured && status >= 400 && status <= 499) {
      const lower = (message ?? "").toLowerCase();
      if (lower.includes("response_format") || lower.includes("json_schema") || lower.includes("structured")) {
        return new OpenRouterUnsupportedFeatureError(
          "Model/provider does not support structured outputs for this request.",
          meta,
        );
      }
    }

    if (status >= 400 && status <= 499) {
      return new OpenRouterUpstreamError(status, message ?? "OpenRouter request failed.", meta);
    }

    return new OpenRouterUpstreamError(status, "OpenRouter upstream error.", meta);
  }
}




================================================
FILE: src/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: src/lib/config/limits.ts
================================================
import type { AccountRole } from "../../types.ts";

export const DAILY_GENERATION_LIMITS: Record<AccountRole, number> = {
  demo: 1,
  full: 5,
};

export function getDailyGenerationLimit(role: AccountRole): number {
  // Dev ergonomics: allow quick iteration without constantly hitting the daily limit.
  // In production, keep strict business limits.
  if (import.meta.env.DEV) {
    return 50;
  }
  return DAILY_GENERATION_LIMITS[role];
}




================================================
FILE: src/lib/services/ai-generation.service.ts
================================================
import type { SupabaseClient } from "../../db/supabase.client.ts";
import type { Json } from "../../db/database.types.ts";
import type {
  AccountRole,
  CardQualityStatus,
  GenerateCardsResponseDto,
  GeneratedCardDto,
} from "../../types.ts";
import crypto from "node:crypto";
import { z } from "zod";
import { getDailyGenerationLimit } from "../config/limits.ts";
import { createOpenRouterServiceFromEnv } from "./openrouter.from-env.ts";
import {
  OpenRouterAuthError,
  OpenRouterConfigError,
  OpenRouterRateLimitError,
  OpenRouterResponseParseError,
  OpenRouterSchemaValidationError,
  OpenRouterTimeoutError,
  OpenRouterUnsupportedFeatureError,
  OpenRouterUpstreamError,
  type OpenRouterJsonSchemaResponseFormat,
  type OpenRouterStructuredSchema,
} from "./openrouter.service.ts";

class HttpError extends Error {
  readonly status: number;
  readonly code: string;
  readonly details?: unknown;

  constructor(status: number, code: string, message: string, details?: unknown) {
    super(message);
    this.status = status;
    this.code = code;
    this.details = details;
  }
}

function utcDateKey(date = new Date()): string {
  // YYYY-MM-DD (UTC)
  return date.toISOString().slice(0, 10);
}

function makeSourceTitle(content: string): string {
  const trimmed = content.trim().replace(/\s+/g, " ");
  const hash = crypto.createHash("md5").update(trimmed).digest("hex").slice(0, 8);
  const base = trimmed.length <= 80 ? trimmed : `${trimmed.slice(0, 77)}...`;
  return `${base} #${hash}`;
}

const aiCardSchema = z.object({
  front: z.string().min(1).max(2000),
  back: z.string().min(1).max(10_000),
  // NOTE: Some providers (e.g. Azure via OpenRouter) require JSON-schema `required`
  // to list *all* keys in `properties`. We therefore make these always present,
  // but allow null to keep them logically optional.
  context: z.string().max(10_000).nullable(),
  difficulty: z.number().int().min(1).max(5).nullable(),
  tags: z.array(z.string().min(1).max(50)).max(20).nullable(),
});

const aiResponseSchema = z.object({
  cards: z.array(aiCardSchema).min(1).max(100),
});

const generateCardsResponseFormat = {
  type: "json_schema",
  json_schema: {
    name: "generate_cards_v1",
    strict: true,
    schema: {
      type: "object",
      additionalProperties: false,
      properties: {
        cards: {
          type: "array",
          minItems: 1,
          maxItems: 100,
          items: {
            type: "object",
            additionalProperties: false,
            properties: {
              front: { type: "string", minLength: 1, maxLength: 2000 },
              back: { type: "string", minLength: 1, maxLength: 10000 },
              context: { anyOf: [{ type: "string", maxLength: 10000 }, { type: "null" }] },
              difficulty: { anyOf: [{ type: "integer", minimum: 1, maximum: 5 }, { type: "null" }] },
              tags: {
                anyOf: [
                  {
                    type: "array",
                    maxItems: 20,
                    items: { type: "string", minLength: 1, maxLength: 50 },
                  },
                  { type: "null" },
                ],
              },
            },
            // Required must include all keys in properties for some providers.
            required: ["front", "back", "context", "difficulty", "tags"],
          },
        },
      },
      required: ["cards"],
    },
  },
} as const satisfies OpenRouterJsonSchemaResponseFormat;

const generateCardsStructuredSchema: OpenRouterStructuredSchema<z.infer<typeof aiResponseSchema>> = {
  response_format: generateCardsResponseFormat,
  parse: (value) => aiResponseSchema.parse(value),
};

async function checkAndIncrementDailyLimit(params: {
  supabase: SupabaseClient;
  userId: string;
  role: AccountRole;
}): Promise<{ remaining_generations: number }> {
  const { supabase, userId, role } = params;
  const limit = getDailyGenerationLimit(role);
  const date = utcDateKey();

  // Preferred path: atomic DB function (avoids race conditions and can bypass RLS safely).
  const { data: rpcRemaining, error: rpcError } = await supabase.rpc("increment_daily_generation", {
    p_user_id: userId,
    p_daily_limit: limit,
  });

  if (!rpcError && typeof rpcRemaining === "number") {
    return { remaining_generations: rpcRemaining };
  }
  if (rpcError) {
    const msg = String((rpcError as any).message ?? "");
    if (msg.includes("daily_limit_exceeded")) {
      throw new HttpError(429, "daily_limit_exceeded", "Daily generation limit exceeded.");
    }
    if (msg.includes("invalid_user_id")) {
      throw new HttpError(500, "invalid_user_id", "Invalid user id for usage tracking.");
    }
    if (msg.includes("invalid_daily_limit")) {
      throw new HttpError(500, "invalid_daily_limit", "Invalid daily limit configuration.");
    }
    // Fall back to legacy behavior only if function is missing.
    const code = String((rpcError as any).code ?? "");
    if (code && !["PGRST202", "42883"].includes(code)) {
      throw new HttpError(500, "usage_stats_write_failed", "Failed to update usage stats.");
    }
  }

  const { data: existing, error: selectError } = await supabase
    .from("user_usage_stats")
    .select("generation_count")
    .eq("user_id", userId)
    .eq("date", date)
    .maybeSingle();

  if (selectError) {
    throw new HttpError(500, "usage_stats_read_failed", "Failed to read usage stats.");
  }

  const used = existing?.generation_count ?? 0;
  if (used >= limit) {
    throw new HttpError(429, "daily_limit_exceeded", "Daily generation limit exceeded.");
  }

  // NOTE: This is not perfectly atomic under concurrency without an RPC/DB function.
  // The composite PK (user_id, date) makes it safe to upsert one row per day.
  const { error: upsertError } = await supabase
    .from("user_usage_stats")
    .upsert(
      {
        user_id: userId,
        date,
        generation_count: used + 1,
      },
      { onConflict: "user_id,date" },
    );

  if (upsertError) {
    throw new HttpError(500, "usage_stats_write_failed", "Failed to update usage stats.");
  }

  return { remaining_generations: limit - (used + 1) };
}

async function assertDeckOwnership(params: {
  supabase: SupabaseClient;
  userId: string;
  deckId: string;
}): Promise<void> {
  const { supabase, userId, deckId } = params;

  const { data, error } = await supabase
    .from("decks")
    .select("id")
    .eq("id", deckId)
    .eq("user_id", userId)
    .maybeSingle();

  if (error) {
    throw new HttpError(500, "deck_lookup_failed", "Failed to validate deck.");
  }
  if (!data) {
    throw new HttpError(404, "deck_not_found", "Deck not found.");
  }
}

async function createSource(params: {
  supabase: SupabaseClient;
  userId: string;
  content: string;
}): Promise<{ sourceId: string }> {
  const { supabase, userId, content } = params;

  const { data, error } = await supabase
    .from("sources")
    .insert({
      user_id: userId,
      title: makeSourceTitle(content),
      content,
      character_count: content.length,
    })
    .select("id")
    .single();

  if (error || !data?.id) {
    throw new HttpError(500, "source_create_failed", "Failed to create source.");
  }

  return { sourceId: data.id };
}

async function generateCardsWithAI(content: string): Promise<z.infer<typeof aiResponseSchema>> {
  const openrouter = createOpenRouterServiceFromEnv();

  const system = [
    "You generate flashcards for an educational app.",
    "Return only data that matches the required JSON schema.",
    "Do not include markdown fences.",
  ].join("\n");

  const user = ["Generate flashcards from the user content.", "", "User content:", content].join("\n");

  try {
    const { data } = await openrouter.sendChatCompletionStructured(
      {
        messages: [
          { role: "system", content: system },
          { role: "user", content: user },
        ],
        params: {
          temperature: 0.2,
          max_tokens: 1200,
        },
      },
      generateCardsStructuredSchema,
    );

    return data;
  } catch (err) {
    if (err instanceof OpenRouterConfigError) {
      throw new HttpError(500, "openrouter_not_configured", "OpenRouter is not configured.");
    }
    if (err instanceof OpenRouterAuthError) {
      throw new HttpError(err.status, "openrouter_auth_error", "AI provider authorization failed.");
    }
    if (err instanceof OpenRouterRateLimitError) {
      throw new HttpError(429, "openrouter_rate_limit", "AI provider rate limit exceeded.");
    }
    if (err instanceof OpenRouterTimeoutError) {
      throw new HttpError(408, "openrouter_timeout", "AI provider request timed out.");
    }
    if (err instanceof OpenRouterUnsupportedFeatureError) {
      throw new HttpError(502, "openrouter_unsupported_feature", "AI provider does not support this feature.");
    }
    if (err instanceof OpenRouterUpstreamError) {
      // Preserve upstream status + message (e.g. model not found, insufficient credits, etc.).
      throw new HttpError(err.status, "openrouter_upstream_error", err.message, { openrouter: err.meta });
    }
    if (err instanceof OpenRouterResponseParseError) {
      throw new HttpError(500, "openrouter_invalid_json", "AI provider returned invalid JSON.");
    }
    if (err instanceof OpenRouterSchemaValidationError) {
      throw new HttpError(500, "openrouter_schema_mismatch", "AI provider returned unexpected JSON shape.");
    }

    throw err;
  }
}

async function insertGeneratedCards(params: {
  supabase: SupabaseClient;
  userId: string;
  sourceId: string;
  deckId?: string;
  cards: z.infer<typeof aiCardSchema>[];
}): Promise<{ cards: GeneratedCardDto[] }> {
  const { supabase, userId, sourceId, deckId, cards } = params;

  const inserts = cards.map((c) => ({
    user_id: userId,
    source_id: sourceId,
    deck_id: deckId ?? null,
    question: c.front,
    answer: c.back,
    context: c.context ?? null,
    difficulty: c.difficulty ?? 3,
    tags: c.tags ?? [],
    quality_status: "draft",
  }));

  const { data, error } = await supabase
    .from("cards")
    .insert(inserts)
    .select("id, question, answer, context, difficulty, tags, quality_status");

  if (error || !data) {
    throw new HttpError(500, "cards_insert_failed", "Failed to save generated cards.");
  }

  const dto: GeneratedCardDto[] = data.map((row) => ({
    id: row.id,
    front: row.question,
    back: row.answer,
    context: row.context,
    difficulty: row.difficulty,
    tags: row.tags,
    quality_status: (row.quality_status ?? "draft") as CardQualityStatus,
  }));

  return { cards: dto };
}

async function logKpiEvent(params: {
  supabase: SupabaseClient;
  userId: string;
  event_type: string;
  metadata: Json;
}): Promise<void> {
  const { supabase, userId, event_type, metadata } = params;

  const { error } = await supabase.from("kpi_events").insert({
    user_id: userId,
    event_type,
    metadata,
  });

  // KPI must never block the main flow.
  if (error) {
    // eslint-disable-next-line no-console
    console.error("[kpi_events] insert failed", error);
  }
}

export async function generateCardsPipeline(params: {
  supabase: SupabaseClient;
  userId: string;
  role: AccountRole;
  content: string;
  deckId?: string;
}): Promise<GenerateCardsResponseDto> {
  const { supabase, userId, role, content, deckId } = params;

  if (deckId) {
    await assertDeckOwnership({ supabase, userId, deckId });
  }

  const { remaining_generations } = await checkAndIncrementDailyLimit({ supabase, userId, role });
  const { sourceId } = await createSource({ supabase, userId, content });

  try {
    const ai = await generateCardsWithAI(content);
    const { cards } = await insertGeneratedCards({
      supabase,
      userId,
      sourceId,
      deckId,
      cards: ai.cards,
    });

    await logKpiEvent({
      supabase,
      userId,
      event_type: "ai_generation",
      metadata: {
        cards_count: cards.length,
        source_id: sourceId,
        deck_id: deckId ?? null,
      } as unknown as Json,
    });

    return {
      source_id: sourceId,
      cards,
      remaining_generations,
    };
  } catch (err) {
    await logKpiEvent({
      supabase,
      userId,
      event_type: "ai_generation_failed",
      metadata: {
        source_id: sourceId,
        deck_id: deckId ?? null,
      } as unknown as Json,
    });

    throw err;
  }
}

export function toHttpError(err: unknown): HttpError {
  if (err instanceof HttpError) return err;
  return new HttpError(500, "internal_error", "Internal server error.");
}




================================================
FILE: src/lib/services/cards-client.service.ts
================================================
import type { CardDto, CardUpdateCommand } from "@/types";

type ApiErrorPayload = {
  status: number;
  code?: string;
  message?: string;
  details?: unknown;
};

async function parseError(response: Response): Promise<ApiErrorPayload> {
  let payload: unknown = null;
  try {
    payload = await response.json();
  } catch {
    payload = null;
  }

  const errorPayload = payload as { error?: ApiErrorPayload } | null;
  return {
    status: response.status,
    code: errorPayload?.error?.code,
    message: errorPayload?.error?.message,
    details: errorPayload?.error?.details,
  };
}

export async function updateCard(cardId: string, command: CardUpdateCommand): Promise<CardDto> {
  const response = await fetch(`/api/cards/${cardId}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(command),
  });

  if (response.ok) {
    const payload = (await response.json()) as { data?: CardDto } | CardDto;
    const card = "data" in payload ? payload.data : payload;
    if (!card?.id) throw { status: 500 };
    return card;
  }

  throw await parseError(response);
}

export async function deleteCard(cardId: string): Promise<void> {
  const response = await fetch(`/api/cards/${cardId}`, { method: "DELETE" });

  if (response.ok) {
    return;
  }

  throw await parseError(response);
}




================================================
FILE: src/lib/services/decks-client.service.ts
================================================
import type {
  DeckCreateCommand,
  DeckDto,
  ListDecksQuery,
  ListDecksResponseDto,
} from "@/types";

type ApiErrorPayload = {
  status: number;
  code?: string;
  message?: string;
  details?: unknown;
};

function toQueryString(query?: ListDecksQuery): string {
  if (!query) {
    return "";
  }

  const params = new URLSearchParams();
  if (typeof query.page === "number") params.set("page", String(query.page));
  if (typeof query.limit === "number") params.set("limit", String(query.limit));
  if (query.search) params.set("search", query.search);

  const queryString = params.toString();
  return queryString ? `?${queryString}` : "";
}

async function parseError(response: Response): Promise<ApiErrorPayload> {
  let payload: unknown = null;
  try {
    payload = await response.json();
  } catch {
    payload = null;
  }

  const errorPayload = payload as { error?: ApiErrorPayload } | null;
  return {
    status: response.status,
    code: errorPayload?.error?.code,
    message: errorPayload?.error?.message,
    details: errorPayload?.error?.details,
  };
}

export async function getDecks(
  query?: ListDecksQuery,
): Promise<ListDecksResponseDto> {
  const response = await fetch(`/api/decks${toQueryString(query)}`);

  if (response.ok) {
    return (await response.json()) as ListDecksResponseDto;
  }

  throw await parseError(response);
}

export async function createDeck(
  command: DeckCreateCommand,
): Promise<DeckDto> {
  const response = await fetch("/api/decks", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(command),
  });

  if (response.ok) {
    const payload = (await response.json()) as { data?: DeckDto } | DeckDto;
    const deck = "data" in payload ? payload.data : payload;
    if (!deck?.id) {
      throw { status: 500 };
    }
    return deck;
  }

  throw await parseError(response);
}



================================================
FILE: src/lib/services/generate-client.service.ts
================================================
import type { GenerateCardsCommand, GenerateCardsResponseDto } from "@/types";

type GenerateClientError = {
  status: number;
  code?: string;
  message?: string;
  details?: unknown;
};

export async function postGenerateCards(
  command: GenerateCardsCommand,
): Promise<GenerateCardsResponseDto> {
  const response = await fetch("/api/ai/generate", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(command),
  });

  if (response.ok) {
    return (await response.json()) as GenerateCardsResponseDto;
  }

  let payload: unknown = null;
  try {
    payload = await response.json();
  } catch {
    payload = null;
  }

  const errorPayload = payload as { error?: GenerateClientError } | null;
  const apiError: GenerateClientError = {
    status: response.status,
    code: errorPayload?.error?.code,
    message: errorPayload?.error?.message,
    details: errorPayload?.error?.details,
  };

  throw apiError;
}



================================================
FILE: src/lib/services/openrouter.from-env.ts
================================================
import { OpenRouterService, type OpenRouterServiceDeps } from "../openrouter.service.ts";

function isPlaceholder(value: string | undefined): boolean {
  if (!value) return true;
  const trimmed = value.trim();
  return trimmed === "" || trimmed === "###";
}

function parsePositiveInt(value: string | undefined, fallback: number): number {
  if (isPlaceholder(value)) return fallback;
  const n = Number(value);
  if (!Number.isFinite(n) || n <= 0) return fallback;
  return Math.floor(n);
}

/**
 * Factory to build `OpenRouterService` from `import.meta.env`.
 * Keeps env parsing centralized and testable.
 */
export function createOpenRouterServiceFromEnv(deps: OpenRouterServiceDeps = {}): OpenRouterService {
  // Treat placeholders as missing to avoid confusing 401s and generic failures in dev.
  const apiKey = isPlaceholder(import.meta.env.OPENROUTER_API_KEY) ? "" : import.meta.env.OPENROUTER_API_KEY;

  const defaultModel = isPlaceholder(import.meta.env.OPENROUTER_DEFAULT_MODEL)
    ? "openai/gpt-4o-mini"
    : import.meta.env.OPENROUTER_DEFAULT_MODEL;

  const requestTimeoutMs = parsePositiveInt(import.meta.env.OPENROUTER_TIMEOUT_MS, 45_000);

  const appReferer = isPlaceholder(import.meta.env.OPENROUTER_HTTP_REFERER)
    ? undefined
    : import.meta.env.OPENROUTER_HTTP_REFERER;

  const appTitle = isPlaceholder(import.meta.env.OPENROUTER_X_TITLE) ? undefined : import.meta.env.OPENROUTER_X_TITLE;

  return new OpenRouterService(
    {
      apiKey,
      defaultModel,
      requestTimeoutMs,
      maxRetries: 2,
      appReferer,
      appTitle,
    },
    deps,
  );
}




================================================
FILE: src/lib/services/openrouter.service.ts
================================================
export * from "../openrouter.service.ts";




================================================
FILE: src/lib/services/source-cards-client.service.ts
================================================
import type { CardDto, ListCardsResponseDto } from "@/types";

type ApiErrorPayload = {
  status: number;
  code?: string;
  message?: string;
  details?: unknown;
};

async function parseError(response: Response): Promise<ApiErrorPayload> {
  let payload: unknown = null;
  try {
    payload = await response.json();
  } catch {
    payload = null;
  }

  const errorPayload = payload as { error?: ApiErrorPayload } | null;
  return {
    status: response.status,
    code: errorPayload?.error?.code,
    message: errorPayload?.error?.message,
    details: errorPayload?.error?.details,
  };
}

export async function getCardsBySourceId(sourceId: string): Promise<CardDto[]> {
  const response = await fetch(`/api/sources/${sourceId}/cards`);

  if (response.ok) {
    const payload = (await response.json()) as ListCardsResponseDto;
    return payload.data ?? [];
  }

  throw await parseError(response);
}




================================================
FILE: src/lib/validators/ai-generate.schema.ts
================================================
import { z } from "zod";

// Shared schema for POST /api/ai/generate
export const generateCardsCommandSchema = z.object({
  content: z.string().min(50).max(100_000),
  deck_id: z.string().uuid().optional(),
});

export type GenerateCardsCommandInput = z.infer<typeof generateCardsCommandSchema>;




================================================
FILE: src/lib/validators/openrouter-schemas.ts
================================================
import { z } from "zod";
import type {
  OpenRouterJsonSchemaResponseFormat,
  OpenRouterStructuredSchema,
} from "../openrouter.service.ts";

export const chatReplyV1Zod = z.object({
  answer: z.string(),
  followUps: z.array(z.string()),
  safety: z.object({
    flagged: z.boolean(),
    reason: z.string(),
  }),
});

export type ChatReplyV1 = z.infer<typeof chatReplyV1Zod>;

export const chatReplyV1ResponseFormat = {
  type: "json_schema",
  json_schema: {
    name: "chat_reply_v1",
    strict: true,
    schema: {
      type: "object",
      additionalProperties: false,
      properties: {
        answer: { type: "string", description: "Odpowiedź asystenta dla użytkownika." },
        followUps: {
          type: "array",
          description: "Proponowane kolejne pytania użytkownika.",
          items: { type: "string" },
        },
        safety: {
          type: "object",
          additionalProperties: false,
          properties: {
            flagged: { type: "boolean", description: "Czy odpowiedź dotyczyła treści ryzykownych." },
            reason: { type: "string", description: "Powód flagi (jeśli flagged=true)." },
          },
          required: ["flagged", "reason"],
        },
      },
      required: ["answer", "followUps", "safety"],
    },
  },
} as const satisfies OpenRouterJsonSchemaResponseFormat;

export const chatReplyV1StructuredSchema: OpenRouterStructuredSchema<ChatReplyV1> = {
  response_format: chatReplyV1ResponseFormat,
  parse: (value) => chatReplyV1Zod.parse(value),
};




================================================
FILE: src/lib/viewmodels/generate.vm.ts
================================================
export type GenerateRequestStatus = "idle" | "loading" | "success" | "error";

export type GenerateApiErrorVm = {
  status?: number;
  code?: string;
  message: string;
  debugDetails?: unknown;
};

export type GenerateValidationVm = {
  content?: { code: "too_short" | "too_long"; message: string } | null;
};

export type GenerateLimitsVm = {
  remainingGenerations?: number;
  isGenerationBlocked: boolean;
  reason?: "limit_reached" | "unknown";
};

export type DeckOptionVm = {
  value: string | null;
  label: string;
  description?: string;
};

export type GenerateFormVm = {
  content: string;
  contentCount: number;
  deckId: string | null;
  touched: { content: boolean };
  validation: GenerateValidationVm;
};

export type GenerateRequestStateVm = {
  status: GenerateRequestStatus;
  lastResponse?: { sourceId: string; remainingGenerations: number };
};



================================================
FILE: src/middleware/index.ts
================================================
import { defineMiddleware } from 'astro:middleware';

import { supabaseClient } from '../db/supabase.client.ts';

export const onRequest = defineMiddleware((context, next) => {
  context.locals.supabase = supabaseClient;
  return next();
});



================================================
FILE: src/pages/generate.astro
================================================
---
import Layout from "../layouts/Layout.astro";
import { GenerateView } from "../components/generate/GenerateView";
---

<Layout title="Generuj fiszki">
  <GenerateView client:load />
</Layout>



================================================
FILE: src/pages/index.astro
================================================
---
import Welcome from "../components/Welcome.astro";
import Layout from "../layouts/Layout.astro";
---

<Layout>
  <Welcome />
</Layout>



================================================
FILE: src/pages/api/decks.ts
================================================
import type { APIRoute } from "astro";
import { z, ZodError } from "zod";

import { DEFAULT_USER_ID } from "../../db/supabase.client.ts";
import type { DeckDto, ListDecksResponseDto } from "../../types.ts";

export const prerender = false;

function json(status: number, body: unknown): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function isUuid(value: string): boolean {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
}

const listDecksQuerySchema = z.object({
  page: z
    .string()
    .optional()
    .transform((v) => (v ? Number(v) : 1))
    .pipe(z.number().int().min(1)),
  limit: z
    .string()
    .optional()
    .transform((v) => (v ? Number(v) : 50))
    .pipe(z.number().int().min(1).max(100)),
  search: z.string().optional(),
});

const createDeckSchema = z.object({
  name: z.string().trim().min(1).max(120),
  description: z.string().trim().max(2000).optional().nullable(),
});

export const GET: APIRoute = async (context) => {
  try {
    const userId = DEFAULT_USER_ID;
    if (!userId || userId.trim() === "###" || !isUuid(userId)) {
      return json(500, {
        error: {
          code: "default_user_not_configured",
          message:
            "DEFAULT_USER_ID is not configured. Set DEFAULT_USER_ID to an existing public.profiles.id UUID.",
        },
      });
    }

    const parsed = listDecksQuerySchema.parse(
      Object.fromEntries(new URL(context.request.url).searchParams.entries()),
    );
    const page = parsed.page;
    const limit = parsed.limit;
    const search = parsed.search?.trim();
    const from = (page - 1) * limit;
    const to = from + limit - 1;

    let query = context.locals.supabase
      .from("decks")
      .select("id,name,description,created_at", { count: "exact" })
      .eq("user_id", userId)
      .order("created_at", { ascending: false })
      .range(from, to);

    if (search) {
      // Search in name/description (simple ilike match).
      query = query.or(`name.ilike.%${search}%,description.ilike.%${search}%`);
    }

    const { data, error, count } = await query;

    if (error) {
      return json(500, { error: { code: "decks_list_failed", message: "Failed to list decks." } });
    }

    const response: ListDecksResponseDto = {
      data: (data ?? []) as DeckDto[],
      meta: {
        total: count ?? 0,
        page,
        limit,
      },
    };

    return json(200, response);
  } catch (err) {
    if (err instanceof ZodError) {
      return json(400, {
        error: {
          code: "validation_error",
          message: "Invalid query parameters.",
          details: err.flatten(),
        },
      });
    }
    return json(500, { error: { code: "internal_error", message: "Internal server error." } });
  }
};

export const POST: APIRoute = async (context) => {
  try {
    const userId = DEFAULT_USER_ID;
    if (!userId || userId.trim() === "###" || !isUuid(userId)) {
      return json(500, {
        error: {
          code: "default_user_not_configured",
          message:
            "DEFAULT_USER_ID is not configured. Set DEFAULT_USER_ID to an existing public.profiles.id UUID.",
        },
      });
    }

    let rawBody: unknown;
    try {
      rawBody = await context.request.json();
    } catch {
      return json(400, { error: { code: "invalid_json", message: "Request body must be valid JSON." } });
    }

    const parsed = createDeckSchema.parse(rawBody);
    const description = parsed.description?.trim() ? parsed.description.trim() : null;

    const { data, error } = await context.locals.supabase
      .from("decks")
      .insert({
        user_id: userId,
        name: parsed.name,
        description,
      })
      .select("id,name,description,created_at")
      .single();

    if (error || !data) {
      return json(500, { error: { code: "deck_create_failed", message: "Failed to create deck." } });
    }

    return json(201, { data: data as DeckDto });
  } catch (err) {
    if (err instanceof ZodError) {
      return json(400, {
        error: {
          code: "validation_error",
          message: "Invalid request body.",
          details: err.flatten(),
        },
      });
    }
    return json(500, { error: { code: "internal_error", message: "Internal server error." } });
  }
};




================================================
FILE: src/pages/api/generate.ts
================================================
export const prerender = false;

// Backwards-compatible alias.
// The implementation plan uses POST /api/ai/generate, but some clients call /api/generate.
export { POST } from "./ai/generate.ts";




================================================
FILE: src/pages/api/ai/generate.ts
================================================
import type { APIRoute } from "astro";
import { ZodError } from "zod";

import { generateCardsCommandSchema } from "../../../lib/validators/ai-generate.schema.ts";
import { generateCardsPipeline, toHttpError } from "../../../lib/services/ai-generation.service.ts";
import type { AccountRole, GenerateCardsResponseDto } from "../../../types.ts";
import { DEFAULT_USER_ID } from "../../../db/supabase.client.ts";

export const prerender = false;

function json(status: number, body: unknown): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function isUuid(value: string): boolean {
  // Simple UUID v4-ish check; good enough for env guardrails.
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
}

export const POST: APIRoute = async (context) => {
  try {
    let rawBody: unknown;
    try {
      rawBody = await context.request.json();
    } catch {
      return json(400, { error: { code: "invalid_json", message: "Request body must be valid JSON." } });
    }

    const parsed = generateCardsCommandSchema.parse(rawBody);

    // TEMP: auth will be handled later; for now we always use DEFAULT_USER_ID.
    const userId = DEFAULT_USER_ID;
    if (!userId || userId.trim() === "###" || !isUuid(userId)) {
      return json(500, {
        error: {
          code: "default_user_not_configured",
          message:
            "DEFAULT_USER_ID is not configured. Set DEFAULT_USER_ID to an existing public.profiles.id UUID.",
        },
      });
    }
    const role: AccountRole = "demo";

    const result: GenerateCardsResponseDto = await generateCardsPipeline({
      supabase: context.locals.supabase,
      userId,
      role,
      content: parsed.content,
      deckId: parsed.deck_id,
    });

    return json(201, result);
  } catch (err) {
    if (err instanceof ZodError) {
      return json(400, {
        error: {
          code: "validation_error",
          message: "Invalid request body.",
          details: err.flatten(),
        },
      });
    }

    // DEV: log the original error for fast debugging.
    if (import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.error("[/api/ai/generate] unhandled error", err);
    }

    const http = toHttpError(err);
    // DEV: include extra details (safe for local debugging).
    if (import.meta.env.DEV) {
      const extra =
        (http as any)?.details ??
        (err instanceof Error ? { name: err.name, message: err.message, stack: err.stack } : { value: String(err) });
      return json(http.status, { error: { code: http.code, message: http.message, details: extra } });
    }

    return json(http.status, { error: { code: http.code, message: http.message } });
  }
};




================================================
FILE: src/pages/api/cards/[card_id].ts
================================================
import type { APIRoute } from "astro";
import { z, ZodError } from "zod";

import { DEFAULT_USER_ID } from "../../../db/supabase.client.ts";
import type { CardDto, CardQualityStatus } from "../../../types.ts";

export const prerender = false;

function json(status: number, body: unknown): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function isUuid(value: string): boolean {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
}

const cardUpdateSchema = z
  .object({
    question: z.string().trim().min(1).max(2000).optional(),
    answer: z.string().trim().min(1).max(10_000).optional(),
    context: z.string().trim().max(10_000).nullable().optional(),
    difficulty: z.number().int().min(1).max(5).nullable().optional(),
    tags: z.array(z.string().trim().min(1).max(50)).max(20).nullable().optional(),
    deck_id: z.string().uuid().nullable().optional(),
    quality_status: z
      .enum(["draft", "ok", "good"] satisfies CardQualityStatus[])
      .optional(),
  })
  .refine((obj) => Object.keys(obj).length > 0, {
    message: "At least one field must be provided.",
  });

export const PATCH: APIRoute = async (context) => {
  try {
    const userId = DEFAULT_USER_ID;
    if (!userId || userId.trim() === "###" || !isUuid(userId)) {
      return json(500, {
        error: {
          code: "default_user_not_configured",
          message:
            "DEFAULT_USER_ID is not configured. Set DEFAULT_USER_ID to an existing public.profiles.id UUID.",
        },
      });
    }

    const cardId = context.params.card_id;
    if (!cardId || !isUuid(cardId)) {
      return json(400, { error: { code: "validation_error", message: "Invalid card_id." } });
    }

    let rawBody: unknown;
    try {
      rawBody = await context.request.json();
    } catch {
      return json(400, { error: { code: "invalid_json", message: "Request body must be valid JSON." } });
    }

    const parsed = cardUpdateSchema.parse(rawBody);

    const { data, error } = await context.locals.supabase
      .from("cards")
      .update(parsed)
      .eq("id", cardId)
      .eq("user_id", userId)
      .select(
        "id, question, answer, context, difficulty, tags, quality_status, deck_id, source_id, created_at, updated_at",
      )
      .maybeSingle();

    if (error) {
      return json(500, { error: { code: "card_update_failed", message: "Failed to update card." } });
    }
    if (!data) {
      return json(404, { error: { code: "card_not_found", message: "Card not found." } });
    }

    return json(200, { data: data as unknown as CardDto });
  } catch (err) {
    if (err instanceof ZodError) {
      return json(400, {
        error: {
          code: "validation_error",
          message: "Invalid request body.",
          details: err.flatten(),
        },
      });
    }
    return json(500, { error: { code: "internal_error", message: "Internal server error." } });
  }
};

export const DELETE: APIRoute = async (context) => {
  try {
    const userId = DEFAULT_USER_ID;
    if (!userId || userId.trim() === "###" || !isUuid(userId)) {
      return json(500, {
        error: {
          code: "default_user_not_configured",
          message:
            "DEFAULT_USER_ID is not configured. Set DEFAULT_USER_ID to an existing public.profiles.id UUID.",
        },
      });
    }

    const cardId = context.params.card_id;
    if (!cardId || !isUuid(cardId)) {
      return json(400, { error: { code: "validation_error", message: "Invalid card_id." } });
    }

    const { error } = await context.locals.supabase
      .from("cards")
      .delete()
      .eq("id", cardId)
      .eq("user_id", userId);

    if (error) {
      return json(500, { error: { code: "card_delete_failed", message: "Failed to delete card." } });
    }

    return json(200, { ok: true });
  } catch {
    return json(500, { error: { code: "internal_error", message: "Internal server error." } });
  }
};




================================================
FILE: src/pages/api/dev/default-user.ts
================================================
import type { APIRoute } from "astro";
import { DEFAULT_USER_ID } from "../../../db/supabase.client.ts";

export const prerender = false;

function json(status: number, body: unknown): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

export const GET: APIRoute = async () => {
  const raw = DEFAULT_USER_ID ?? "";
  const configured = Boolean(raw && raw.trim() !== "" && raw.trim() !== "###");

  return json(200, {
    default_user_id: configured ? raw : null,
    configured,
    hint: configured
      ? null
      : "Set DEFAULT_USER_ID in .env to an existing public.profiles.id UUID (dev-only shortcut).",
  });
};




================================================
FILE: src/pages/api/dev/reset-usage.ts
================================================
import type { APIRoute } from "astro";
import { z, ZodError } from "zod";

import { DEFAULT_USER_ID } from "../../../db/supabase.client.ts";

export const prerender = false;

function json(status: number, body: unknown): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function isUuid(value: string): boolean {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
}

function utcDateKey(date = new Date()): string {
  return date.toISOString().slice(0, 10);
}

const resetUsageSchema = z
  .object({
    // If true: delete all rows for DEFAULT_USER_ID. Otherwise only for `date`.
    all: z.boolean().optional(),
    // YYYY-MM-DD (UTC). If omitted and all=false, defaults to today.
    date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
  })
  .optional();

// DEV-ONLY helper endpoint to reset daily generation usage.
export const POST: APIRoute = async (context) => {
  try {
    const userId = DEFAULT_USER_ID;
    if (!userId || userId.trim() === "###" || !isUuid(userId)) {
      return json(500, {
        error: {
          code: "default_user_not_configured",
          message:
            "DEFAULT_USER_ID is not configured. Set DEFAULT_USER_ID to an existing public.profiles.id UUID.",
        },
      });
    }

    let rawBody: unknown = undefined;
    if (context.request.headers.get("content-type")?.includes("application/json")) {
      try {
        rawBody = await context.request.json();
      } catch {
        return json(400, { error: { code: "invalid_json", message: "Request body must be valid JSON." } });
      }
    }

    const parsed = resetUsageSchema.parse(rawBody);
    const resetAll = parsed?.all === true;
    const date = parsed?.date ?? utcDateKey();

    const query = context.locals.supabase.from("user_usage_stats").delete().eq("user_id", userId);
    const { error } = resetAll ? await query : await query.eq("date", date);

    if (error) {
      return json(500, { error: { code: "reset_failed", message: "Failed to reset usage stats." } });
    }

    return json(200, { ok: true, user_id: userId, reset: resetAll ? "all" : "date", date: resetAll ? null : date });
  } catch (err) {
    if (err instanceof ZodError) {
      return json(400, {
        error: { code: "validation_error", message: "Invalid request body.", details: err.flatten() },
      });
    }
    return json(500, { error: { code: "internal_error", message: "Internal server error." } });
  }
};




================================================
FILE: src/pages/api/sources/[source_id]/cards.ts
================================================
import type { APIRoute } from "astro";
import { z, ZodError } from "zod";

import { DEFAULT_USER_ID } from "../../../../db/supabase.client.ts";
import type { CardDto, ListCardsResponseDto } from "../../../../types.ts";

export const prerender = false;

function json(status: number, body: unknown): Response {
  return new Response(JSON.stringify(body), {
    status,
    headers: { "Content-Type": "application/json" },
  });
}

function isUuid(value: string): boolean {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value);
}

const listCardsQuerySchema = z.object({
  page: z
    .string()
    .optional()
    .transform((v) => (v ? Number(v) : 1))
    .pipe(z.number().int().min(1)),
  limit: z
    .string()
    .optional()
    .transform((v) => (v ? Number(v) : 200))
    .pipe(z.number().int().min(1).max(500)),
});

export const GET: APIRoute = async (context) => {
  try {
    const userId = DEFAULT_USER_ID;
    if (!userId || userId.trim() === "###" || !isUuid(userId)) {
      return json(500, {
        error: {
          code: "default_user_not_configured",
          message:
            "DEFAULT_USER_ID is not configured. Set DEFAULT_USER_ID to an existing public.profiles.id UUID.",
        },
      });
    }

    const sourceId = context.params.source_id;
    if (!sourceId || !isUuid(sourceId)) {
      return json(400, { error: { code: "validation_error", message: "Invalid source_id." } });
    }

    const parsed = listCardsQuerySchema.parse(
      Object.fromEntries(new URL(context.request.url).searchParams.entries()),
    );
    const page = parsed.page;
    const limit = parsed.limit;
    const from = (page - 1) * limit;
    const to = from + limit - 1;

    const { data, error, count } = await context.locals.supabase
      .from("cards")
      .select(
        "id, question, answer, context, difficulty, tags, quality_status, deck_id, source_id, created_at, updated_at",
        { count: "exact" },
      )
      .eq("user_id", userId)
      .eq("source_id", sourceId)
      .order("created_at", { ascending: true })
      .range(from, to);

    if (error) {
      return json(500, { error: { code: "cards_list_failed", message: "Failed to list cards." } });
    }

    const response: ListCardsResponseDto = {
      data: (data ?? []) as unknown as CardDto[],
      meta: {
        total: count ?? 0,
        page,
        limit,
      },
    };

    return json(200, response);
  } catch (err) {
    if (err instanceof ZodError) {
      return json(400, {
        error: {
          code: "validation_error",
          message: "Invalid query parameters.",
          details: err.flatten(),
        },
      });
    }
    return json(500, { error: { code: "internal_error", message: "Internal server error." } });
  }
};




================================================
FILE: src/pages/generate/results.astro
================================================
---
import Layout from "../../layouts/Layout.astro";
import { GenerateResultsView } from "../../components/generate/GenerateResultsView";
---

<Layout title="Wyniki generowania">
  <GenerateResultsView client:load />
</Layout>




================================================
FILE: src/styles/global.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}



================================================
FILE: supabase/config.toml
================================================
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "10xdevs-project"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false
# Paths to self-signed certificate pair.
# cert_path = "../certs/my-cert.pem"
# key_path = "../certs/my-key.pem"

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# Maximum amount of time to wait for health check when starting the local database.
health_timeout = "2m"
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 17

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# If disabled, migrations will be skipped during a db push or reset.
enabled = true
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[db.network_restrictions]
# Enable management of network restrictions.
enabled = false
# List of IPv4 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv4 connections. Set empty array to block all IPs.
allowed_cidrs = ["0.0.0.0/0"]
# List of IPv6 CIDR blocks allowed to connect to the database.
# Defaults to allow all IPv6 connections. Set empty array to block all IPs.
allowed_cidrs_v6 = ["::/0"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

# Allow connections via S3 compatible clients
[storage.s3_protocol]
enabled = true

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Store analytical data in S3 for running ETL jobs over Iceberg Catalog
# This feature is only available on the hosted platform.
[storage.analytics]
enabled = false
max_namespaces = 5
max_tables = 10
max_catalogs = 2

# Analytics Buckets is available to Supabase Pro plan.
# [storage.analytics.buckets.my-warehouse]

# Store vector embeddings in S3 for large and durable datasets
# This feature is only available on the hosted platform.
[storage.vector]
enabled = false
max_buckets = 10
max_indexes = 5

# Vector Buckets is available to Supabase Pro plan.
# [storage.vector.buckets.documents-openai]

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# JWT issuer URL. If not set, defaults to the local API URL (http://127.0.0.1:<port>/auth/v1).
# jwt_issuer = ""
# Path to JWT signing key. DO NOT commit your signing keys file to git.
# signing_keys_path = "./signing_keys.json"
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30
# Number of Web3 logins that can be made in a 5 minute interval per IP address.
web3 = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

# Uncomment to customize notification email template
# [auth.email.notification.password_changed]
# enabled = true
# subject = "Your password has been changed"
# content_path = "./templates/password_changed_notification.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a new user is created and allows developers to reject the request based on the incoming user object.
# [auth.hook.before_user_created]
# enabled = true
# uri = "pg-functions://postgres/auth/before-user-created-hook"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `x`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false
# If enabled, it will allow the user to successfully authenticate when the provider does not return an email address.
email_optional = false

# Allow Solana wallet holders to sign in to your project via the Sign in with Solana (SIWS, EIP-4361) standard.
# You can configure "web3" rate limit in the [auth.rate_limit] section and set up [auth.captcha] if self-hosting.
[auth.web3.solana]
enabled = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

# OAuth server configuration
[auth.oauth_server]
# Enable OAuth server functionality
enabled = false
# Path for OAuth consent flow UI
authorization_url_path = "/oauth/consent"
# Allow dynamic client registration
allow_dynamic_registration = false

[edge_runtime]
enabled = true
# Supported request policies: `oneshot`, `per_worker`.
# `per_worker` (default) — enables hot reload during local development.
# `oneshot` — fallback mode if hot reload causes issues (e.g. in large repos or with symlinks).
policy = "per_worker"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 2

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"



================================================
FILE: supabase/migrations/20260130140000_create_profiles.sql
================================================
-- migration: create profiles table
-- purpose: store extended user data linked to supabase auth system
-- affected tables: profiles
-- special considerations: this table extends auth.users and is the foundation for user-related data

-- create profiles table
-- this table stores extended user information beyond what's in auth.users
-- each profile is linked 1:1 with a user in the auth.users table
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  email text not null,
  account_role text not null default 'demo' check (account_role in ('demo', 'full')),
  last_active_at timestamp with time zone default now(),
  created_at timestamp with time zone default now()
);

-- enable row level security on profiles table
-- this ensures users can only access their own profile data
alter table public.profiles enable row level security;

-- rls policy: allow authenticated users to select their own profile
-- rationale: users need to read their own profile information
-- intended behavior: returns true only if the requesting user's id matches the profile id
create policy "profiles_select_own_authenticated"
  on public.profiles
  for select
  to authenticated
  using (auth.uid() = id);

-- rls policy: allow anonymous users to select their own profile
-- rationale: demo users (anonymous) also need to read their profile
-- intended behavior: returns true only if the requesting user's id matches the profile id
create policy "profiles_select_own_anon"
  on public.profiles
  for select
  to anon
  using (auth.uid() = id);

-- rls policy: allow authenticated users to update their own profile
-- rationale: users need to update their profile information (e.g., last_active_at)
-- intended behavior: returns true only if the requesting user's id matches the profile id
create policy "profiles_update_own_authenticated"
  on public.profiles
  for update
  to authenticated
  using (auth.uid() = id)
  with check (auth.uid() = id);

-- rls policy: allow anonymous users to update their own profile
-- rationale: demo users (anonymous) also need to update their profile
-- intended behavior: returns true only if the requesting user's id matches the profile id
create policy "profiles_update_own_anon"
  on public.profiles
  for update
  to anon
  using (auth.uid() = id)
  with check (auth.uid() = id);

-- rls policy: allow authenticated users to insert their own profile
-- rationale: new users need to create their profile during signup
-- intended behavior: returns true only if the new profile id matches the requesting user's id
create policy "profiles_insert_own_authenticated"
  on public.profiles
  for insert
  to authenticated
  with check (auth.uid() = id);

-- rls policy: allow anonymous users to insert their own profile
-- rationale: demo users (anonymous) need to create their profile
-- intended behavior: returns true only if the new profile id matches the requesting user's id
create policy "profiles_insert_own_anon"
  on public.profiles
  for insert
  to anon
  with check (auth.uid() = id);

-- create index on email for faster lookups
create index if not exists idx_profiles_email on public.profiles(email);

-- add comment to table for documentation
comment on table public.profiles is 'Extended user profiles linked to supabase auth system';
comment on column public.profiles.account_role is 'User account type: demo (limited) or full (paid)';
comment on column public.profiles.last_active_at is 'Timestamp of last user activity';



================================================
FILE: supabase/migrations/20260130140100_create_decks.sql
================================================
-- migration: create decks table
-- purpose: create containers (decks) for organizing flashcards
-- affected tables: decks
-- special considerations: deck names must be unique per user

-- create decks table
-- this table stores flashcard decks (collections) that users create to organize their cards
-- each deck belongs to a specific user and must have a unique name within that user's decks
create table if not exists public.decks (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  description text,
  created_at timestamp with time zone default now(),
  -- ensure deck names are unique per user
  constraint unique_deck_name_per_user unique (user_id, name)
);

-- enable row level security on decks table
-- this ensures users can only access their own decks
alter table public.decks enable row level security;

-- rls policy: allow authenticated users to select their own decks
-- rationale: users need to view their own decks
-- intended behavior: returns true only if the deck belongs to the requesting user
create policy "decks_select_own_authenticated"
  on public.decks
  for select
  to authenticated
  using (auth.uid() = user_id);

-- rls policy: allow anonymous users to select their own decks
-- rationale: demo users need to view their own decks
-- intended behavior: returns true only if the deck belongs to the requesting user
create policy "decks_select_own_anon"
  on public.decks
  for select
  to anon
  using (auth.uid() = user_id);

-- rls policy: allow authenticated users to insert their own decks
-- rationale: users need to create new decks
-- intended behavior: returns true only if the new deck user_id matches the requesting user
create policy "decks_insert_own_authenticated"
  on public.decks
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- rls policy: allow anonymous users to insert their own decks
-- rationale: demo users need to create new decks
-- intended behavior: returns true only if the new deck user_id matches the requesting user
create policy "decks_insert_own_anon"
  on public.decks
  for insert
  to anon
  with check (auth.uid() = user_id);

-- rls policy: allow authenticated users to update their own decks
-- rationale: users need to edit their deck names and descriptions
-- intended behavior: returns true only if the deck belongs to the requesting user
create policy "decks_update_own_authenticated"
  on public.decks
  for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- rls policy: allow anonymous users to update their own decks
-- rationale: demo users need to edit their deck names and descriptions
-- intended behavior: returns true only if the deck belongs to the requesting user
create policy "decks_update_own_anon"
  on public.decks
  for update
  to anon
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- rls policy: allow authenticated users to delete their own decks
-- rationale: users need to remove unwanted decks
-- intended behavior: returns true only if the deck belongs to the requesting user
create policy "decks_delete_own_authenticated"
  on public.decks
  for delete
  to authenticated
  using (auth.uid() = user_id);

-- rls policy: allow anonymous users to delete their own decks
-- rationale: demo users need to remove unwanted decks
-- intended behavior: returns true only if the deck belongs to the requesting user
create policy "decks_delete_own_anon"
  on public.decks
  for delete
  to anon
  using (auth.uid() = user_id);

-- create composite index on user_id and name for unique constraint and faster lookups
-- this index is automatically created by the unique constraint above
create index if not exists idx_decks_user_id on public.decks(user_id);

-- add comments to table and constraints for documentation
comment on table public.decks is 'Flashcard decks (collections) for organizing cards';
comment on column public.decks.name is 'Deck name, must be unique per user';
comment on column public.decks.description is 'Optional description of the deck content';
comment on constraint unique_deck_name_per_user on public.decks is 'Ensures deck names are unique within a user''s collection';



================================================
FILE: supabase/migrations/20260130140200_create_sources.sql
================================================
-- migration: create sources table
-- purpose: store original source texts pasted by users for flashcard generation
-- affected tables: sources
-- special considerations: content field has technical limit of ~100k characters

-- create sources table
-- this table stores the original text content that users provide to generate flashcards
-- each source belongs to a specific user and can generate multiple cards
create table if not exists public.sources (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  content text not null,
  character_count integer not null,
  created_at timestamp with time zone default now()
);

-- enable row level security on sources table
-- this ensures users can only access their own sources
alter table public.sources enable row level security;

-- rls policy: allow authenticated users to select their own sources
-- rationale: users need to view their own source texts
-- intended behavior: returns true only if the source belongs to the requesting user
create policy "sources_select_own_authenticated"
  on public.sources
  for select
  to authenticated
  using (auth.uid() = user_id);

-- rls policy: allow anonymous users to select their own sources
-- rationale: demo users need to view their own source texts
-- intended behavior: returns true only if the source belongs to the requesting user
create policy "sources_select_own_anon"
  on public.sources
  for select
  to anon
  using (auth.uid() = user_id);

-- rls policy: allow authenticated users to insert their own sources
-- rationale: users need to create new source texts
-- intended behavior: returns true only if the new source user_id matches the requesting user
create policy "sources_insert_own_authenticated"
  on public.sources
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- rls policy: allow anonymous users to insert their own sources
-- rationale: demo users need to create new source texts
-- intended behavior: returns true only if the new source user_id matches the requesting user
create policy "sources_insert_own_anon"
  on public.sources
  for insert
  to anon
  with check (auth.uid() = user_id);

-- rls policy: allow authenticated users to update their own sources
-- rationale: users need to edit their source texts
-- intended behavior: returns true only if the source belongs to the requesting user
create policy "sources_update_own_authenticated"
  on public.sources
  for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- rls policy: allow anonymous users to update their own sources
-- rationale: demo users need to edit their source texts
-- intended behavior: returns true only if the source belongs to the requesting user
create policy "sources_update_own_anon"
  on public.sources
  for update
  to anon
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- rls policy: allow authenticated users to delete their own sources
-- rationale: users need to remove unwanted source texts
-- intended behavior: returns true only if the source belongs to the requesting user
create policy "sources_delete_own_authenticated"
  on public.sources
  for delete
  to authenticated
  using (auth.uid() = user_id);

-- rls policy: allow anonymous users to delete their own sources
-- rationale: demo users need to remove unwanted source texts
-- intended behavior: returns true only if the source belongs to the requesting user
create policy "sources_delete_own_anon"
  on public.sources
  for delete
  to anon
  using (auth.uid() = user_id);

-- create index on user_id for faster user-specific queries
create index if not exists idx_sources_user_id on public.sources(user_id);

-- add comments to table and columns for documentation
comment on table public.sources is 'Original source texts provided by users for flashcard generation';
comment on column public.sources.content is 'Source text content with recommended technical limit of 100k characters';
comment on column public.sources.character_count is 'Number of characters in the content field';



================================================
FILE: supabase/migrations/20260130140300_create_cards.sql
================================================
-- migration: create cards table
-- purpose: store flashcards with questions, answers, metadata and relationships to decks/sources
-- affected tables: cards
-- special considerations: cards can exist without a deck (deck_id nullable), source_id set to null on source deletion

-- create cards table
-- this is the main table for storing flashcards with their content, metadata, and relationships
-- cards belong to a user and optionally to a deck and source
create table if not exists public.cards (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  deck_id uuid references public.decks(id) on delete set null,
  source_id uuid references public.sources(id) on delete set null,
  question text not null,
  answer text not null,
  context text,
  tags text[] default '{}',
  difficulty smallint default 3 check (difficulty between 1 and 5),
  quality_status text default 'draft' check (quality_status in ('draft', 'ok', 'good')),
  is_manual_override boolean default false,
  external_metadata jsonb default '{}',
  last_synced_at timestamp with time zone,
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- enable row level security on cards table
-- this ensures users can only access their own cards
alter table public.cards enable row level security;

-- rls policy: allow authenticated users to select their own cards
-- rationale: users need to view all their flashcards
-- intended behavior: returns true only if the card belongs to the requesting user
create policy "cards_select_own_authenticated"
  on public.cards
  for select
  to authenticated
  using (auth.uid() = user_id);

-- rls policy: allow anonymous users to select their own cards
-- rationale: demo users need to view all their flashcards
-- intended behavior: returns true only if the card belongs to the requesting user
create policy "cards_select_own_anon"
  on public.cards
  for select
  to anon
  using (auth.uid() = user_id);

-- rls policy: allow authenticated users to insert their own cards
-- rationale: users need to create new flashcards
-- intended behavior: returns true only if the new card user_id matches the requesting user
create policy "cards_insert_own_authenticated"
  on public.cards
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- rls policy: allow anonymous users to insert their own cards
-- rationale: demo users need to create new flashcards
-- intended behavior: returns true only if the new card user_id matches the requesting user
create policy "cards_insert_own_anon"
  on public.cards
  for insert
  to anon
  with check (auth.uid() = user_id);

-- rls policy: allow authenticated users to update their own cards
-- rationale: users need to edit their flashcards content and metadata
-- intended behavior: returns true only if the card belongs to the requesting user
create policy "cards_update_own_authenticated"
  on public.cards
  for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- rls policy: allow anonymous users to update their own cards
-- rationale: demo users need to edit their flashcards content and metadata
-- intended behavior: returns true only if the card belongs to the requesting user
create policy "cards_update_own_anon"
  on public.cards
  for update
  to anon
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

-- rls policy: allow authenticated users to delete their own cards
-- rationale: users need to remove unwanted flashcards
-- intended behavior: returns true only if the card belongs to the requesting user
create policy "cards_delete_own_authenticated"
  on public.cards
  for delete
  to authenticated
  using (auth.uid() = user_id);

-- rls policy: allow anonymous users to delete their own cards
-- rationale: demo users need to remove unwanted flashcards
-- intended behavior: returns true only if the card belongs to the requesting user
create policy "cards_delete_own_anon"
  on public.cards
  for delete
  to anon
  using (auth.uid() = user_id);

-- create indexes for efficient querying
-- index on user_id for fast user-specific card queries
create index if not exists idx_cards_user_id on public.cards(user_id);

-- index on deck_id for fast deck-specific card queries
create index if not exists idx_cards_deck_id on public.cards(deck_id);

-- gin index on tags array for efficient tag-based searches
create index if not exists idx_cards_tags on public.cards using gin(tags);

-- index on quality_status for filtering by card quality
create index if not exists idx_cards_quality_status on public.cards(quality_status);

-- create trigger function to automatically update updated_at timestamp
create or replace function public.update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- create trigger to call the update function before each update
create trigger update_cards_updated_at
  before update on public.cards
  for each row
  execute function public.update_updated_at_column();

-- add comments to table and columns for documentation
comment on table public.cards is 'Main flashcard table storing questions, answers, and metadata';
comment on column public.cards.deck_id is 'Optional reference to containing deck, null if card is unorganized';
comment on column public.cards.source_id is 'Optional reference to source text, null if manually created or source deleted';
comment on column public.cards.question is 'The question/prompt side of the flashcard';
comment on column public.cards.answer is 'The answer/response side of the flashcard';
comment on column public.cards.context is 'Optional contextual information to help understand the card';
comment on column public.cards.tags is 'Array of user-defined tags for categorization';
comment on column public.cards.difficulty is 'Subjective difficulty rating from 1 (easiest) to 5 (hardest)';
comment on column public.cards.quality_status is 'Quality assessment: draft (needs review), ok (acceptable), good (high quality)';
comment on column public.cards.is_manual_override is 'True if user manually edited AI-generated content';
comment on column public.cards.external_metadata is 'JSON metadata for SRS integration and future extensions';
comment on column public.cards.last_synced_at is 'Timestamp of last sync with external SRS system';



================================================
FILE: supabase/migrations/20260130140400_create_user_usage_stats.sql
================================================
-- migration: create user_usage_stats table
-- purpose: track daily ai generation limits per user
-- affected tables: user_usage_stats
-- special considerations: composite primary key (user_id, date) allows atomic increment operations

-- create user_usage_stats table
-- this table tracks daily usage statistics for each user to enforce ai generation limits
-- the composite key allows for efficient daily limit checks and atomic counter updates
create table if not exists public.user_usage_stats (
  user_id uuid not null references public.profiles(id) on delete cascade,
  date date not null default current_date,
  generation_count integer default 0,
  primary key (user_id, date)
);

-- enable row level security on user_usage_stats table
-- users can only view their own statistics
alter table public.user_usage_stats enable row level security;

-- rls policy: allow authenticated users to select their own usage stats
-- rationale: users need to see their own daily usage to understand remaining limits
-- intended behavior: returns true only if the stats belong to the requesting user
create policy "user_usage_stats_select_own_authenticated"
  on public.user_usage_stats
  for select
  to authenticated
  using (auth.uid() = user_id);

-- rls policy: allow anonymous users to select their own usage stats
-- rationale: demo users need to see their own daily usage
-- intended behavior: returns true only if the stats belong to the requesting user
create policy "user_usage_stats_select_own_anon"
  on public.user_usage_stats
  for select
  to anon
  using (auth.uid() = user_id);

-- note: insert/update operations should be handled by server-side functions (rpc) or triggers
-- to ensure proper validation and atomic operations
-- users should not directly modify usage stats through standard queries

-- create index on date for efficient date-based queries and cleanup operations
create index if not exists idx_user_usage_stats_date on public.user_usage_stats(date);

-- add comments to table and columns for documentation
comment on table public.user_usage_stats is 'Daily AI generation usage statistics per user for enforcing limits';
comment on column public.user_usage_stats.user_id is 'Reference to the user profile';
comment on column public.user_usage_stats.date is 'Date of usage (UTC timezone)';
comment on column public.user_usage_stats.generation_count is 'Number of AI generations performed on this date';
comment on constraint user_usage_stats_pkey on public.user_usage_stats is 'Composite key ensures one record per user per day';



================================================
FILE: supabase/migrations/20260130140500_create_kpi_events.sql
================================================
-- migration: create kpi_events table
-- purpose: log analytics events for tracking user behavior and kpis
-- affected tables: kpi_events
-- special considerations: users can only insert events, not read them (analytics/admin access only)

-- create kpi_events table
-- this table stores analytics events for tracking user actions and calculating kpis
-- events include session starts, ai generations, card edits, accepts, and deletions
create table if not exists public.kpi_events (
  id bigint primary key generated always as identity,
  user_id uuid not null references public.profiles(id) on delete cascade,
  event_type text not null,
  metadata jsonb default '{}',
  created_at timestamp with time zone default now()
);

-- enable row level security on kpi_events table
-- users can only insert their own events, reading is restricted to admin/analytics
alter table public.kpi_events enable row level security;

-- rls policy: allow authenticated users to insert their own events
-- rationale: users need to log their actions for analytics
-- intended behavior: returns true only if the new event user_id matches the requesting user
create policy "kpi_events_insert_own_authenticated"
  on public.kpi_events
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- rls policy: allow anonymous users to insert their own events
-- rationale: demo users also need to log their actions for analytics
-- intended behavior: returns true only if the new event user_id matches the requesting user
create policy "kpi_events_insert_own_anon"
  on public.kpi_events
  for insert
  to anon
  with check (auth.uid() = user_id);

-- note: no select/update/delete policies for regular users
-- kpi_events are write-only for users; reading is restricted to admins/analytics systems
-- this prevents users from accessing or modifying analytics data

-- create index on user_id for efficient per-user analytics queries
create index if not exists idx_kpi_events_user_id on public.kpi_events(user_id);

-- create index on event_type for efficient event type filtering in analytics
create index if not exists idx_kpi_events_event_type on public.kpi_events(event_type);

-- create index on created_at for time-based analytics queries
create index if not exists idx_kpi_events_created_at on public.kpi_events(created_at);

-- create composite index for common analytics queries (user + time range)
create index if not exists idx_kpi_events_user_created on public.kpi_events(user_id, created_at);

-- add comments to table and columns for documentation
comment on table public.kpi_events is 'Analytics event log for tracking user behavior and calculating KPIs';
comment on column public.kpi_events.event_type is 'Type of event: session_start, ai_generation, card_edit, card_accept, card_delete, etc.';
comment on column public.kpi_events.metadata is 'Additional JSON data about the event (flexible schema for different event types)';
comment on column public.kpi_events.created_at is 'Timestamp when the event occurred (UTC timezone)';



================================================
FILE: supabase/migrations/20260130150000_create_increment_daily_generation_rpc.sql
================================================
-- migration: create increment_daily_generation RPC
-- purpose: atomically enforce and increment daily generation limits
-- affected objects: function public.increment_daily_generation
-- special considerations:
-- - SECURITY DEFINER to allow atomic upsert even when RLS blocks direct updates
-- - designed for backend use; current dev mode has no auth, so we do not enforce auth.uid() here

create or replace function public.increment_daily_generation(
  p_user_id uuid,
  p_daily_limit integer
)
returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  v_date date := current_date;
  v_used integer := 0;
begin
  if p_user_id is null then
    raise exception 'invalid_user_id';
  end if;

  if p_daily_limit is null or p_daily_limit <= 0 then
    raise exception 'invalid_daily_limit';
  end if;

  -- Read current usage (if any)
  select coalesce(generation_count, 0)
    into v_used
  from public.user_usage_stats
  where user_id = p_user_id and date = v_date;

  if v_used >= p_daily_limit then
    raise exception 'daily_limit_exceeded';
  end if;

  -- Atomic upsert: if row exists, increment; else insert with 1
  insert into public.user_usage_stats (user_id, date, generation_count)
  values (p_user_id, v_date, 1)
  on conflict (user_id, date)
  do update set generation_count = public.user_usage_stats.generation_count + 1;

  return p_daily_limit - (v_used + 1);
end;
$$;

-- allow calling from API clients (dev) and server-side
grant execute on function public.increment_daily_generation(uuid, integer) to anon, authenticated;




================================================
FILE: supabase/migrations/20260130151000_create_profiles_on_auth_user_trigger.sql
================================================
-- migration: auto-create profiles on auth.users insert
-- purpose: ensure public.profiles exists for every auth user
-- affected objects: function public.handle_new_user, trigger on auth.users

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, email)
  values (new.id, coalesce(new.email, 'dev@example.com'))
  on conflict (id) do nothing;

  return new;
end;
$$;

drop trigger if exists on_auth_user_created on auth.users;

create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();




================================================
FILE: .ai/api-plan.md
================================================
# REST API Plan

This document outlines the REST API architecture for the AI Flashcards application, designed to support the functionality described in the PRD and adhering to the database schema.

## 1. Resources

The API is structured around the following core resources, mapping directly to the database entities:

| Resource | Database Table | Description |
| :--- | :--- | :--- |
| **Decks** | `decks` | Collections of flashcards organized by the user. |
| **Cards** | `cards` | The core flashcard entities containing questions, answers, and metadata. |
| **Sources** | `sources` | Original text content uploaded/pasted by users to generate cards. |
| **Generation** | N/A (Service) | The AI service endpoint for converting text into flashcards. |
| **User Status** | `profiles`, `user_usage_stats` | User account information, limits, and daily usage statistics. |
| **Export** | N/A (Service) | Functionality to export deck data for external SRS tools. |

---

## 2. Endpoints

### 2.1. AI Generation (Core Feature)

**Generate Cards**
*   **Method**: `POST`
*   **URL**: `/api/ai/generate`
*   **Description**: Triggers the AI pipeline. Checks user limits, creates a `source` record, calls the AI provider (OpenRouter), parses the response, and inserts `cards` with `quality_status='draft'`.
*   **Success Code**: `201 Created`
*   **Request Body**:
    ```json
    {
      "content": "string (min 50 chars, max 100k chars)",
      "deck_id": "uuid (optional)"
    }
    ```
*   **Response Body**:
    ```json
    {
      "source_id": "uuid",
      "cards": [
        {
          "id": "uuid",
          "front": "string",
          "back": "string",
          "context": "string",
          "difficulty": "number",
          "tags": ["string"],
          "quality_status": "draft"
        }
      ],
      "remaining_generations": "number"
    }
    ```
*   **Notes**:
    *   API uses `front`/`back` in response, mapped from DB `question`/`answer`.
*   **Business Logic**:
    *   Verify `user_usage_stats` for daily generation limit (5 for full, less for demo).
    *   Create `kpi_events` entry (`event_type: 'ai_generation'`).
    *   Calculate cost/usage.

### 2.2. Decks

**List Decks**
*   **Method**: `GET`
*   **URL**: `/api/decks`
*   **Query Params**: `page`, `limit`, `search` (optional)
*   **Response**: `data: Deck[]`, `meta: { total, page, limit }`

**Create Deck**
*   **Method**: `POST`
*   **URL**: `/api/decks`
*   **Request Body**:
    ```json
    {
      "name": "string",
      "description": "string (optional)"
    }
    ```
*   **Validation**: Check deck count limit (max 50).

**Get Deck**
*   **Method**: `GET`
*   **URL**: `/api/decks/:id`

**Update Deck**
*   **Method**: `PATCH`
*   **URL**: `/api/decks/:id`
*   **Request Body**: `{ "name": "string", "description": "string" }`

**Delete Deck**
*   **Method**: `DELETE`
*   **URL**: `/api/decks/:id`
*   **Logic**: Cascades to delete cards (handled by DB `ON DELETE CASCADE` or logic depending on requirement to keep orphaned cards). *Note: DB schema says `cards.deck_id` ON DELETE SET NULL, so cards become unorganized.*

### 2.3. Cards

**List Cards**
*   **Method**: `GET`
*   **URL**: `/api/cards`
*   **Query Params**:
    *   `deck_id` (optional)
    *   `source_id` (optional)
    *   `quality_status` (optional)
    *   `tags` (optional)
    *   `sort` (e.g., `created_at_desc`)
*   **Response**: `data: Card[]`, `meta: Pagination`

**Create Card (Manual & Bulk)**
*   **Method**: `POST`
*   **URL**: `/api/cards`
*   **Request Body**: Accepts a single card object or an array of card objects.
    ```json
    // Single object or Array:
    [
      {
        "question": "string",
        "answer": "string",
        "context": "string",
        "deck_id": "uuid",
        "tags": ["string"],
        "difficulty": 3
      }
    ]
    ```
*   **Validation**: Check card count limit (max 2000) against the total number of cards to be created.

**Update Card**
*   **Method**: `PATCH`
*   **URL**: `/api/cards/:id`
*   **Request Body**: Partial card object with fields:
    `question`, `answer`, `context`, `deck_id`, `tags`, `difficulty`, `quality_status`
*   **Logic**: If critical fields change, update `kpi_events` (`event_type: 'card_edit'`).

**Batch Update Cards**
*   **Method**: `PATCH`
*   **URL**: `/api/cards/batch`
*   **Description**: Efficiently update status or tags for multiple cards (US-003).
*   **Request Body**:
    ```json
    {
      "card_ids": ["uuid"],
      "action": "update_status" | "add_tags" | "delete",
      "payload": {
        "quality_status": "ok", // if action is update_status
        "tags": ["new_tag"]     // if action is add_tags
      }
    }
    ```

**Delete Card**
*   **Method**: `DELETE`
*   **URL**: `/api/cards/:id`

### 2.4. User & Status

**Get User Status**
*   **Method**: `GET`
*   **URL**: `/api/me/status`
*   **Description**: Returns user role, current usage vs limits, and demo status.
*   **Response**:
    ```json
    {
      "id": "uuid",
      "role": "demo" | "full",
      "limits": {
        "cards_created": 150,
        "cards_limit": 2000,
        "decks_created": 5,
        "decks_limit": 50,
        "daily_generations_used": 2,
        "daily_generations_limit": 5
      }
    }
    ```

### 2.5. Export

**Export Data**
*   **Method**: `GET`
*   **URL**: `/api/export`
*   **Query Params**: `deck_id` (optional), `format` (json/csv)
*   **Description**: Generates a download of the user's cards for external SRS.

---

## 3. Authentication & Authorization

*   **Mechanism**: Supabase Auth (JWT).
*   **Implementation**:
    *   All API routes (except public assets) are protected via middleware.
    *   The backend extracts the `access_token` from the request Authorization header or Cookie.
    *   `auth.uid()` is used to enforce Row Level Security (RLS) policies at the database level.
    *   API endpoints verify the user exists before proceeding.

## 4. Validation & Business Logic

### 4.1. Validation Rules (Zod Schemas)
*   **Cards**:
    *   `question`: min 1 char, required.
    *   `answer`: min 1 char, required.
    *   `difficulty`: integer 1-5.
    *   `quality_status`: enum ['draft', 'ok', 'good'].
*   **Decks**:
    *   `name`: required, max length 100.
*   **AI Request**:
    *   `content`: max 100,000 characters (soft limit per PRD/DB schema).

### 4.2. Business Logic Enforcement
1.  **Limits**:
    *   Before any `POST` to `/decks` or `/cards`, query `count(*)` (or a pre-calculated counter) to ensure user is within limits (50 decks, 2000 cards).
    *   Before `POST` to `/ai/generate`, check `user_usage_stats` for today's date. If record missing, create it. If `generation_count` >= limit, reject with `429 Too Many Requests`.

2.  **KPI Tracking**:
    *   Use an internal helper `logEvent(userId, type, metadata)` to insert into `kpi_events` asynchronously (or fire-and-forget) to avoid slowing down the main response.
    *   Events to track: `session_start`, `ai_generation`, `card_accept`, `export`.

3.  **Demo vs Full**:
    *   Endpoints check `profiles.account_role`.
    *   Demo users might have stricter limits (e.g., 1 generation/day) handled in the Limit logic.

## 5. Error Handling

Standard HTTP status codes will be used:
*   `200 OK`: Success.
*   `201 Created`: Resource created successfully.
*   `400 Bad Request`: Validation failure (response includes field-level error details).
*   `401 Unauthorized`: Missing or invalid JWT.
*   `403 Forbidden`: User tries to access resource they don't own (enforced by RLS/Logic).
*   `429 Too Many Requests`: Limit reached (daily generations or account limits).
*   `500 Internal Server Error`: Unhandled application error.

---

## 6. DTO Shapes (API Responses)

These shapes describe what the API returns. They align with `src/types.ts`.

**Deck**
```json
{
  "id": "uuid",
  "name": "string",
  "description": "string | null",
  "created_at": "timestamp"
}
```

**Card**
```json
{
  "id": "uuid",
  "question": "string",
  "answer": "string",
  "context": "string | null",
  "difficulty": "number",
  "tags": ["string"],
  "quality_status": "draft" | "ok" | "good",
  "deck_id": "uuid | null",
  "source_id": "uuid | null",
  "created_at": "timestamp",
  "updated_at": "timestamp"
}
```

**GeneratedCard** (AI response)
```json
{
  "id": "uuid",
  "front": "string",
  "back": "string",
  "context": "string | null",
  "difficulty": "number",
  "tags": ["string"],
  "quality_status": "draft"
}
```



================================================
FILE: .ai/db-plan.md
================================================
# Schemat Bazy Danych PostgreSQL (Supabase)

Ten dokument zawiera kompleksowy schemat bazy danych dla projektu AI Flashcards, zaprojektowany zgodnie z wymaganiami PRD, notatkami z sesji planowania oraz wybranym stackiem technologicznym.

## 1. Lista tabel

### `profiles`
Przechowuje rozszerzone dane użytkowników powiązane z systemem auth Supabase.
This table is managed by Supabase Auth.
- `id`: `uuid` (PRIMARY KEY, REFERENCES auth.users)
- `email`: `text` (NOT NULL)
- `account_role`: `text` (CHECK: role IN ('demo', 'full'), DEFAULT 'demo')
- `last_active_at`: `timestamp with time zone` (DEFAULT now())
- `created_at`: `timestamp with time zone` (DEFAULT now())

### `sources`
Przechowuje oryginalne teksty źródłowe wklejone przez użytkowników.
- `id`: `uuid` (PRIMARY KEY, DEFAULT gen_random_uuid())
- `user_id`: `uuid` (NOT NULL, REFERENCES profiles(id) ON DELETE CASCADE)
- `title`: `text` (NOT NULL)
- `content`: `text` (NOT NULL) - *Zalecany limit techniczny: 100k znaków*
- `character_count`: `integer` (NOT NULL)
- `created_at`: `timestamp with time zone` (DEFAULT now())

### `decks`
Kontenery na fiszki (talie).
- `id`: `uuid` (PRIMARY KEY, DEFAULT gen_random_uuid())
- `user_id`: `uuid` (NOT NULL, REFERENCES profiles(id) ON DELETE CASCADE)
- `name`: `text` (NOT NULL)
- `description`: `text`
- `created_at`: `timestamp with time zone` (DEFAULT now())
- *Constraint: UNIQUE (user_id, name)*

### `cards`
Główna tabela przechowująca fiszki.
- `id`: `uuid` (PRIMARY KEY, DEFAULT gen_random_uuid())
- `user_id`: `uuid` (NOT NULL, REFERENCES profiles(id) ON DELETE CASCADE)
- `deck_id`: `uuid` (NULLABLE, REFERENCES decks(id) ON DELETE SET NULL)
- `source_id`: `uuid` (NULLABLE, REFERENCES sources(id) ON DELETE SET NULL)
- `question`: `text` (NOT NULL)
- `answer`: `text` (NOT NULL)
- `context`: `text`
- `tags`: `text[]` (DEFAULT '{}')
- `difficulty`: `smallint` (CHECK: difficulty BETWEEN 1 AND 5, DEFAULT 3)
- `quality_status`: `text` (CHECK: quality_status IN ('draft', 'ok', 'good'), DEFAULT 'draft')
- `is_manual_override`: `boolean` (DEFAULT false)
- `external_metadata`: `jsonb` (DEFAULT '{}') - *Dla integracji SRS*
- `last_synced_at`: `timestamp with time zone`
- `created_at`: `timestamp with time zone` (DEFAULT now())
- `updated_at`: `timestamp with time zone` (DEFAULT now())

### `user_usage_stats`
Tabela do śledzenia dziennych limitów generacji AI.
- `user_id`: `uuid` (NOT NULL, REFERENCES profiles(id) ON DELETE CASCADE)
- `date`: `date` (NOT NULL, DEFAULT CURRENT_DATE)
- `generation_count`: `integer` (DEFAULT 0)
- `PRIMARY KEY (user_id, date)`

### `kpi_events`
Rejestr zdarzeń analitycznych.
- `id`: `bigint` (PRIMARY KEY GENERATED ALWAYS AS IDENTITY)
- `user_id`: `uuid` (NOT NULL, REFERENCES profiles(id) ON DELETE CASCADE)
- `event_type`: `text` (NOT NULL) - *np. 'session_start', 'ai_generation', 'card_edit', 'card_accept', 'card_delete'*
- `metadata`: `jsonb` (DEFAULT '{}') - *Dodatkowe dane o zdarzeniu*
- `created_at`: `timestamp with time zone` (DEFAULT now())

## 2. Relacje między tabelami

1.  **profiles -> sources**: Jeden użytkownik może mieć wiele źródeł (1:N).
2.  **profiles -> decks**: Jeden użytkownik może mieć wiele decków (1:N).
3.  **profiles -> cards**: Jeden użytkownik może mieć wiele fiszek (1:N).
4.  **decks -> cards**: Jeden deck zawiera wiele fiszek (1:N). Fiszka może nie należeć do żadnego decku (deck_id IS NULL).
5.  **sources -> cards**: Jedno źródło może wygenerować wiele fiszek (1:N). Usunięcie źródła ustawia source_id w fiszkach na NULL.
6.  **profiles -> user_usage_stats**: Statystyki użycia per użytkownik per dzień (1:N).
7.  **profiles -> kpi_events**: Logi zdarzeń użytkownika (1:N).

## 3. Indeksy

- `idx_cards_user_id`: B-tree na `cards(user_id)` - szybkie filtrowanie fiszek użytkownika.
- `idx_cards_deck_id`: B-tree na `cards(deck_id)` - szybkie pobieranie fiszek z decku.
- `idx_cards_tags`: GIN na `cards(tags)` - wydajne przeszukiwanie po tagach.
- `idx_cards_quality_status`: B-tree na `cards(quality_status)` - filtrowanie po statusie.
- `idx_decks_user_id_name`: UNIQUE INDEX na `decks(user_id, name)` - unikalność nazw decków per użytkownik.
- `idx_kpi_events_user_id`: B-tree na `kpi_events(user_id)` - analityka per użytkownik.
- `idx_user_usage_stats_date`: B-tree na `user_usage_stats(date)` - optymalizacja zapytań o statystyki dzienne.

## 4. Zasady PostgreSQL (RLS)

Wszystkie tabele mają włączone Row Level Security (RLS).

- **profiles**:
  - SELECT: `auth.uid() = id`
  - UPDATE: `auth.uid() = id`
- **sources / decks / cards**:
  - ALL: `auth.uid() = user_id`
- **user_usage_stats**:
  - SELECT: `auth.uid() = user_id`
  - *Modyfikacja tylko przez funkcje serwerowe (RPC) lub triggery.*
- **kpi_events**:
  - INSERT: `auth.uid() = user_id`
  - SELECT: Brak dostępu dla użytkownika (tylko dla adminów/analityki).

## 5. Dodatkowe uwagi projektowe

1.  **Typy danych**:
    - Użycie `smallint` dla `difficulty` (1-5) oszczędza miejsce.
    - `text[]` dla tagów z indeksem GIN jest optymalne dla przewidywanej skali (2000 fiszek/użytkownik).
    - `jsonb` w `external_metadata` zapewnia elastyczność dla przyszłych integracji SRS bez zmian w schemacie.
2.  **Strategia usuwania**:
    - `ON DELETE CASCADE` dla relacji z `profiles` zapewnia czystość danych przy usunięciu konta.
    - `ON DELETE SET NULL` dla `source_id` i `deck_id` w tabeli `cards` chroni owoce pracy użytkownika.
3.  **Limity i wydajność**:
    - Tabela `user_usage_stats` z kluczem złożonym `(user_id, date)` pozwala na atomowe inkrementowanie liczników bez skomplikowanych zadań cron.
    - Limity (np. 50 decków, 2000 fiszek) powinny być sprawdzane w funkcjach bazy danych (RPC) przed wykonaniem operacji zapisu.
4.  **Strefa czasowa**:
    - Wszystkie limity dzienne w `user_usage_stats` są resetowane zgodnie z czasem UTC (standard Supabase), co upraszcza logikę backendu.



================================================
FILE: .ai/generate-view-implementation-plan.md
================================================
# Plan implementacji widoku Generuj

## 1. Przegląd
Widok **Generuj** (`/generate`) służy do wklejenia tekstu źródłowego, opcjonalnego wyboru/utworzenia decka, uruchomienia generacji fiszek przez AI (`POST /api/ai/generate`) oraz przejścia do widoku wyników generacji (filtrowanych po `source_id`). Widok musi jasno komunikować limity (w szczególności dzienny limit generacji), zachowywać draft tekstu przy błędach/nawigacji i nie ujawniać szczegółów błędów serwera.

## 2. Routing widoku
- **Ścieżka**: `/generate`
- **Plik routingu (Astro)**: `src/pages/generate.astro`
  - Renderuje layout aplikacji (jeśli istnieje) i montuje komponent React widoku (np. `GenerateView`) jako island (`client:load` lub `client:visible`).
- **Nawigacja po sukcesie**: przekierowanie do `/generate/results?source_id=<uuid>` (zgodnie z UI planem).

## 3. Struktura komponentów
Główne komponenty widoku (React):
- `GenerateView` (kontener, orkiestracja stanu i API)
- `LimitBanner` (komunikaty limitów/429 + prewencyjne blokady)
- `GenerateTextInput` (textarea + licznik znaków + autosave)
- `DeckPicker` (wybór decka + opcja “Bez decka (Oczekujące)”)
  - `CreateDeckModal` (tworzenie decka “w locie”)
- `GenerateSubmitButton` (submit + disabled/loading)
- `GenerateProgressPanel` (progres generacji + statusy)

Wysokopoziomowy diagram drzewa komponentów:

```
GeneratePage (Astro)
└─ GenerateView (React)
   ├─ LimitBanner
   ├─ GenerateTextInput
   ├─ DeckPicker
   │  └─ CreateDeckModal
   ├─ GenerateSubmitButton
   └─ GenerateProgressPanel
```

## 4. Szczegóły komponentów

### GenerateView
- **Opis komponentu**: Kontener widoku. Składa UI, trzyma stan formularza i integruje API: pobranie decków (jeśli dostępne), pobranie statusu/limitów użytkownika (jeśli dostępne) oraz wywołanie generacji.
- **Główne elementy**:
  - `main` / `section` jako wrapper treści
  - nagłówek widoku (`h1`: “Generuj fiszki”)
  - obszar formularza (`form`) oraz panel statusu
- **Obsługiwane zdarzenia**:
  - `onChangeContent(content: string)` z `GenerateTextInput`
  - `onSelectDeck(deckId: string | null)` z `DeckPicker`
  - `onCreateDeckRequested()` -> otwarcie modala
  - `onDeckCreated(deck: DeckDto)` -> aktualizacja listy decków + ustawienie wybranego decka
  - `onSubmit()` -> wywołanie `POST /api/ai/generate`
  - `onRetry()` (opcjonalnie) -> ponowienie submitu po błędzie sieci/500
- **Warunki walidacji (szczegółowe)**:
  - `content`:
    - wymagane
    - min `50` znaków
    - max `100000` znaków
  - `deck_id`:
    - opcjonalne (może być `null`/`undefined`)
    - jeśli podane: ma być UUID (format weryfikowany client-side jako “guardrail”, backend i tak waliduje)
  - prewencyjne blokady:
    - gdy trwa request generacji -> blokada ponownego submitu
    - gdy znany jest limit i `remaining_generations <= 0` -> blokada submitu (i pokazanie `LimitBanner`)
- **Typy (DTO i ViewModel)**:
  - DTO: `GenerateCardsCommand`, `GenerateCardsResponseDto`, `DeckDto`, `UserStatusDto`
  - VM: `GenerateFormVm`, `GenerateLimitsVm`, `GenerateApiErrorVm`, `DeckOptionVm`
- **Props (interfejs komponentu)**:
  - Docelowo brak (widok routowany), ewentualnie:
    - `initialContent?: string` (np. z query / SSR)
    - `initialDeckId?: string | null`

### LimitBanner
- **Opis komponentu**: Spójny banner/alert do komunikacji limitów i błędów limitowych (szczególnie `429 Too Many Requests`). Powinien wspierać tryb prewencyjny (“nie możesz teraz generować”) i tryb reaktywny (odpowiedź 429 z API).
- **Główne elementy**:
  - `div`/`section` z rolą `alert` (dla krytycznych blokad)
  - treść: nagłówek + opis + ewentualne “co dalej”
  - opcjonalny przycisk “Pokaż szczegóły” (dev/debug) – bez ujawniania wrażliwych danych
- **Obsługiwane zdarzenia**:
  - `onDismiss()` (opcjonalnie)
  - `onShowDetails()` (opcjonalnie)
- **Warunki walidacji**:
  - Brak (prezentacja), ale musi umieć obsłużyć brak danych “kiedy odblokuje” (API może nie zwracać daty resetu).
- **Typy**:
  - VM: `GenerateLimitsVm`, `GenerateApiErrorVm`
- **Props**:
  - `limits: GenerateLimitsVm`
  - `error?: GenerateApiErrorVm | null`
  - `onDismiss?: () => void`

### GenerateTextInput
- **Opis komponentu**: Tekst wejściowy do wklejenia materiału. Pokazuje licznik znaków i walidację. Musi autosave’ować draft do storage i odtwarzać po odświeżeniu/nawigacji.
- **Główne elementy**:
  - `label` + `textarea` (z opisem “min 50, max 100k”)
  - licznik znaków (np. `p`/`span`)
  - komunikat błędu walidacji (np. `p role="alert"`)
- **Obsługiwane zdarzenia**:
  - `onChange` -> `onContentChange(value)`
  - `onBlur` (opcjonalnie) -> wymuszenie zapisu do storage
  - `onClear` (opcjonalnie) -> wyczyszczenie treści + storage
- **Warunki walidacji**:
  - `content.length < 50` -> błąd “Za krótki tekst”
  - `content.length > 100000` -> błąd “Za długi tekst”
  - UX: nie pokazuj błędu “min 50” natychmiast po wejściu; pokaż po `touched` lub po submit.
- **Typy**:
  - VM: `GenerateFormVm` (pole `content`, `contentCount`, `validation`)
- **Props**:
  - `value: string`
  - `minLength: number` (50)
  - `maxLength: number` (100000)
  - `disabled?: boolean`
  - `validation?: { state: "idle" | "error"; message?: string }`
  - `onContentChange: (next: string) => void`
  - `onClear?: () => void`

### DeckPicker
- **Opis komponentu**: Wybór decka dla generowanych fiszek lub opcja “Bez decka (Oczekujące)”. Powinien umożliwiać otwarcie modala tworzenia nowego decka.
- **Główne elementy**:
  - `label`
  - selektor (np. `Select` z shadcn/ui) z listą decków
  - pozycja “Bez decka (Oczekujące)” mapowana na `deck_id = null`
  - przycisk “Utwórz deck” otwierający modal
- **Obsługiwane zdarzenia**:
  - `onValueChange(deckId | null)`
  - `onCreateDeckClick()`
- **Warunki walidacji**:
  - Brak wymogu wybrania decka; `null` jest poprawne.
  - Jeśli widok zna limit decków i jest osiągnięty -> wyłącz “Utwórz deck” i pokaż informację (opcjonalnie).
- **Typy**:
  - DTO: `DeckDto`
  - VM: `DeckOptionVm`
- **Props**:
  - `value: string | null`
  - `options: DeckOptionVm[]`
  - `disabled?: boolean`
  - `onChange: (deckId: string | null) => void`
  - `onCreateDeck: () => void`

### CreateDeckModal
- **Opis komponentu**: Modal do tworzenia decka “w locie” bez opuszczania widoku i bez utraty draftu tekstu.
- **Główne elementy**:
  - `Dialog` (shadcn/ui) z zarządzaniem fokusem
  - formularz: `name` (required), `description` (opcjonalnie)
  - przyciski: “Anuluj”, “Utwórz”
- **Obsługiwane zdarzenia**:
  - `onOpenChange(isOpen)`
  - `onSubmit({ name, description })`
  - `onSuccess(deck)` -> przekazanie do rodzica
- **Warunki walidacji**:
  - `name`:
    - wymagane
    - max długość: `100` (zgodnie z API planem)
  - ochrona przed double submit (disabled + spinner)
- **Typy**:
  - DTO: `DeckCreateCommand`, `DeckDto`
  - VM: `CreateDeckFormVm`, `CreateDeckErrorVm`
- **Props**:
  - `open: boolean`
  - `onOpenChange: (open: boolean) => void`
  - `onCreated: (deck: DeckDto) => void`

### GenerateSubmitButton
- **Opis komponentu**: Przycisk submitu generacji, uwzględniający walidację i limity.
- **Główne elementy**:
  - `button type="submit"` (shadcn `Button`)
  - loader/spinner w stanie `loading`
- **Obsługiwane zdarzenia**:
  - `onClick` (ale finalnie submit ma iść z `form onSubmit`)
- **Warunki walidacji**:
  - disabled jeśli:
    - `isSubmitting === true`
    - `content.length < 50 || content.length > 100000`
    - `remaining_generations` znane i `<= 0`
- **Typy**:
  - VM: `GenerateFormVm`, `GenerateLimitsVm`
- **Props**:
  - `disabled: boolean`
  - `loading: boolean`
  - `label?: string` (domyślnie “Generuj”)

### GenerateProgressPanel
- **Opis komponentu**: Prezentuje stan procesu: idle/loading/success/error. W praktyce, przy sukcesie widok nawiguję do wyników; panel może pokazać krótki stan przejściowy (“Gotowe, przekierowuję…”).
- **Główne elementy**:
  - loader + komunikat w trakcie
  - success message
  - error summary (bez szczegółów serwera) + opcja retry
- **Obsługiwane zdarzenia**:
  - `onRetry()` (opcjonalnie)
- **Warunki walidacji**:
  - Brak (prezentacja)
- **Typy**:
  - VM: `GenerateRequestStateVm`, `GenerateApiErrorVm`
- **Props**:
  - `state: GenerateRequestStateVm`
  - `error?: GenerateApiErrorVm | null`
  - `onRetry?: () => void`

## 5. Typy
Widok powinien opierać się o istniejące DTO z `src/types.ts` oraz zdefiniować lekkie ViewModel’e (VM) dla UI.

### DTO (z istniejących typów)
- `GenerateCardsCommand`
  - `content: string`
  - `deck_id?: string` (uuid) — w UI reprezentowane jako `string | null` i mapowane do `undefined` gdy `null`
- `GenerateCardsResponseDto`
  - `source_id: string` (uuid)
  - `cards: GeneratedCardDto[]`
  - `remaining_generations: number`
- `GeneratedCardDto`
  - `id: string`
  - `front: string`
  - `back: string`
  - `context: string | null`
  - `difficulty: number`
  - `tags: string[]`
  - `quality_status: "draft" | "ok" | "good"` (dla generacji spodziewane `"draft"`)
- `DeckDto` (dla listy decków)
- `DeckCreateCommand` (dla modala tworzenia decka)
- `UserStatusDto` (dla limitów; jeśli endpoint jest dostępny globalnie)

### Nowe typy ViewModel (do dodania w frontendzie)
Zalecane miejsce: `src/lib/viewmodels/generate.vm.ts` (lub analogicznie).

- `type GenerateRequestStatus = "idle" | "loading" | "success" | "error"`

- `type GenerateApiErrorVm = {
    status?: number;
    code?: string;
    message: string;            // tekst przyjazny dla użytkownika
    debugDetails?: unknown;     // opcjonalnie tylko w dev (np. pełne body)
  }`

- `type GenerateValidationVm = {
    content?: { code: "too_short" | "too_long"; message: string } | null;
  }`

- `type GenerateLimitsVm = {
    remainingGenerations?: number;  // undefined gdy nieznane
    isGenerationBlocked: boolean;   // wynikowa flaga do UI
    reason?: "limit_reached" | "unknown";
  }`

- `type DeckOptionVm = {
    value: string | null;       // null = Bez decka
    label: string;
    description?: string;
  }`

- `type GenerateFormVm = {
    content: string;
    contentCount: number;
    deckId: string | null;
    touched: { content: boolean };
    validation: GenerateValidationVm;
  }`

- `type GenerateRequestStateVm = {
    status: GenerateRequestStatus;
    lastResponse?: { sourceId: string; remainingGenerations: number };
  }`

## 6. Zarządzanie stanem
Stan lokalny w `GenerateView` + 1–2 custom hooki dla porządku i testowalności.

### Zmienne stanu (minimalny zestaw)
- `content: string`
- `deckId: string | null`
- `touchedContent: boolean` (czy pokazać walidację)
- `requestStatus: "idle" | "loading" | "success" | "error"`
- `error: GenerateApiErrorVm | null`
- `remainingGenerations: number | undefined`:
  - źródła: `GET /api/me/status` (jeśli dostępne) i/lub odpowiedź z `POST /api/ai/generate`
- `decksState`:
  - `decks: DeckDto[]`
  - `isDecksLoading: boolean`
  - `decksError: GenerateApiErrorVm | null`
- `isCreateDeckOpen: boolean`

### Custom hooki (zalecane)
- `useGenerateDraft(storageKey: string)`
  - **Cel**: autosave `content` do `localStorage`/`sessionStorage` i odtwarzanie przy mount.
  - **API**: `{ value, setValue, clear }`
  - **Uwagi**: nie zapisuj nic wrażliwego poza draftem tekstu; draft jest wymaganiem UX.

- `useGenerateCards()`
  - **Cel**: enkapsulacja wywołania `POST /api/ai/generate` i mapowania błędów na `GenerateApiErrorVm`.
  - **API**: `{ mutate(command), status, error, data }`

- (opcjonalnie) `useDecks()` i `useUserStatus()`
  - **Cel**: pobranie danych do `DeckPicker` i limitów.
  - **Uwaga**: jeśli aplikacja ma już “server state” (np. TanStack Query), wdrażaj jako query + cache. Jeśli nie – proste `useEffect` + `fetch`.

## 7. Integracja API

### POST `/api/ai/generate`
- **Request DTO**: `GenerateCardsCommand`
  - `content`: string (min 50, max 100k)
  - `deck_id?`: uuid (opcjonalnie)
- **Response DTO**: `GenerateCardsResponseDto`
  - `source_id`: uuid
  - `cards`: `GeneratedCardDto[]`
  - `remaining_generations`: number
- **Akcje frontendowe**:
  - przed requestem:
    - walidacja `content`
    - ustaw `requestStatus="loading"`, wyczyść `error`
  - po sukcesie 201:
    - zaktualizuj `remainingGenerations` z odpowiedzi
    - nawiguj do `/generate/results?source_id=<source_id>`
    - (opcjonalnie) zachowaj draft lub wyczyść go po udanym przejściu; rekomendacja: **nie czyścić natychmiast**, bo użytkownik może wrócić “wstecz” i oczekiwać treści
  - po błędzie:
    - mapuj błędy na przyjazny komunikat
    - nie gub draftu (`content` zostaje)

### GET `/api/decks` (dla `DeckPicker`)
- **Cel**: lista decków do wyboru.
- **Akcje frontendowe**: pobierz przy mount, pokaż loading/empty state, umożliw “Utwórz deck”.

### POST `/api/decks` (dla `CreateDeckModal`)
- **Request DTO**: `DeckCreateCommand` (`name`, `description?`)
- **Akcje frontendowe**:
  - po sukcesie: dodaj deck do listy i ustaw go jako wybrany
  - po błędzie limitu decków: pokaż `LimitBanner` lub inline błąd w modalu

### GET `/api/me/status` (opcjonalne, jeśli istnieje globalnie)
- **Cel**: uzyskać rolę demo/full i limity; wyświetlić `remaining_generations` (z `daily_generations_limit - daily_generations_used`).
- **Akcje frontendowe**: pobierz w App Shell i przekaż przez kontekst/store; w widoku Generuj korzystaj z tej wartości do prewencyjnej blokady.

## 8. Interakcje użytkownika
- **Wklejenie/edycja tekstu**:
  - licznik znaków aktualizuje się na bieżąco
  - autosave draftu do storage
  - po przekroczeniu limitów: pokazanie komunikatu walidacji i blokada submitu
- **Wybór decka**:
  - zmiana wyboru aktualizuje `deckId`
  - wybór “Bez decka (Oczekujące)” ustawia `deckId = null`
- **Utworzenie decka w locie**:
  - klik “Utwórz deck” -> otwarcie modala
  - po utworzeniu: modal się zamyka, nowy deck jest wybrany
- **Uruchomienie generacji**:
  - klik “Generuj”/submit formularza
  - pokazanie `GenerateProgressPanel` w stanie loading
  - blokada ponownego submitu i edycji (co najmniej przycisk; opcjonalnie cały formularz)
- **Po sukcesie**:
  - krótki komunikat + automatyczna nawigacja do wyników
- **Po błędzie**:
  - czytelny komunikat (bez szczegółów serwera)
  - możliwość ponowienia (dla sieci/500)
  - dla 429: wyraźny banner limitu + blokada generacji

## 9. Warunki i walidacja
Warunki wynikające z API planu i implementacji endpointu:
- **Body musi być JSON**: UI zawsze wysyła JSON (`Content-Type: application/json`).
- **`content`**:
  - min 50 znaków
  - max 100k znaków
  - weryfikacja:
    - w `GenerateTextInput` (inline, po `touched` lub submit)
    - w `GenerateView` przed wywołaniem API (twarda blokada submitu)
- **`deck_id`**:
  - opcjonalne
  - weryfikacja:
    - `DeckPicker` zawsze dostarcza `string | null`
    - przy budowie requestu: jeśli `null` -> pomiń pole (`undefined`)
    - opcjonalny “UUID guardrail” w `GenerateView` (np. regex) aby nie wysłać śmieci
- **Limity generacji**:
  - backend egzekwuje limit i zwraca `429` przy przekroczeniu
  - UI:
    - prewencyjnie blokuje submit, jeśli zna `remainingGenerations <= 0`
    - reaktywnie obsługuje `429` i pokazuje `LimitBanner`
- **Nie ujawniać szczegółów serwera**:
  - UI prezentuje `error.message` ogólny
  - opcja “Pokaż szczegóły” wyłącznie w dev (lub za flagą) i bez wrażliwych danych

## 10. Obsługa błędów
Scenariusze i sugerowana obsługa:
- **400 validation_error** (Zod):
  - UI: pokaż “Niepoprawne dane formularza” + wskaż pole `content` jeśli dotyczy
  - zachowaj draft i fokus na polu z błędem
- **400 invalid_json**:
  - praktycznie nie powinno wystąpić z UI; pokaż komunikat ogólny + retry
- **401 Unauthorized** (przyszłościowo, gdy auth będzie włączony):
  - zachowaj draft
  - przekieruj do `/login` i po powrocie odtwórz treść
- **429 Too Many Requests**:
  - pokaż `LimitBanner` jako blokujący
  - zablokuj submit do czasu kolejnej doby (UI nie musi znać exact time)
- **500+ / błąd sieci**:
  - pokaż komunikat “Coś poszło nie tak. Spróbuj ponownie.”
  - umożliw retry
  - nie gub draftu
- **Nieoczekiwane shape odpowiedzi**:
  - zabezpiecz parsing (try/catch + fallback error)
  - loguj w konsoli tylko w dev

## 11. Kroki implementacji
1. Utwórz routing widoku:
   - dodaj `src/pages/generate.astro`, osadź `GenerateView` jako komponent React.
2. Dodaj komponenty widoku w `src/components/generate/`:
   - `GenerateView.tsx`, `GenerateTextInput.tsx`, `DeckPicker.tsx`, `CreateDeckModal.tsx`, `GenerateSubmitButton.tsx`, `GenerateProgressPanel.tsx`, `LimitBanner.tsx`.
3. Zaimplementuj typy ViewModel:
   - dodaj plik np. `src/lib/viewmodels/generate.vm.ts` z typami VM (bez duplikowania DTO).
4. Zaimplementuj `useGenerateDraft`:
   - zapis `content` do storage (debounce ~300–500ms), odczyt przy mount, opcja clear.
5. Zaimplementuj klienta API dla generacji:
   - funkcja `postGenerateCards(command: GenerateCardsCommand): Promise<GenerateCardsResponseDto>`
   - mapowanie błędów `{ error: { code, message } }` na `GenerateApiErrorVm`.
6. Podłącz submit w `GenerateView`:
   - walidacja `content` (50–100k)
   - budowa requestu (deckId `null` -> pomiń `deck_id`)
   - stany `loading/error`
   - po 201: nawigacja do `/generate/results?source_id=...`.
7. Dodaj integrację decków (jeśli endpointy są gotowe):
   - `GET /api/decks` do `DeckPicker`
   - `POST /api/decks` w `CreateDeckModal`, po sukcesie ustaw nowy deck.
8. Dodaj obsługę limitów:
   - jeśli istnieje `GET /api/me/status`: pobieraj globalnie i w `GenerateView` licz `remainingGenerations`
   - obsłuż 429: `LimitBanner` + blokada submitu.
9. Dopnij A11y i UX:
   - `label` dla textarea/select
   - `role="alert"` dla krytycznych błędów
   - focus na pierwszym błędzie po submit
   - blokada double submit.
10. Dodaj stany UI:
   - skeleton/loading dla decków
   - empty state gdy brak decków
   - loading state dla generacji.
11. (Opcjonalnie) Dodaj test plan manualny:
   - przypadki: <50, >100k, 201, 400, 429, network error, create deck, draft persistence.




================================================
FILE: .ai/generate-view-test-plan.md
================================================
# Test plan: widok Generuj

## Walidacja treści
- Tekst < 50 znaków: blokada submitu, komunikat walidacji po blur/submit.
- Tekst > 100000 znaków: blokada submitu, komunikat walidacji.
- Poprawny tekst: przycisk aktywny.

## Integracja generacji
- 201: przekierowanie do `/generate/results?source_id=...`, remaining_generations aktualizuje limit.
- 400: komunikat o niepoprawnych danych, brak utraty draftu.
- 429: `LimitBanner` + blokada generacji, brak retry.
- 500 / network: komunikat ogólny + możliwość retry.

## Draft
- Wpisz tekst, odśwież stronę: treść zostaje.
- Wyczyść treść: draft znika z localStorage.

## Decki
- Ładowanie listy: helper "Ładuję decki...".
- Pusta lista: helper "Brak decków...".
- Tworzenie decka: modal, po sukcesie nowy deck wybrany.
- 429 przy tworzeniu: błąd w modalu + zablokowany przycisk "Utwórz deck".



================================================
FILE: .ai/openrouter-service-implementation-plan.md
================================================
[Binary file]


================================================
FILE: .ai/prd.md
================================================
# Dokument wymagań produktu (PRD) - AI Flashcards
## 1. Przegląd produktu
- Empatyczna aplikacja webowa, która automatycznie przekształca dowolny tekst w gotowe fiszki edukacyjne wspierane podpowiedziami AI (pytanie, odpowiedź, kontekst, tagi, poziom trudności) i prostym trybem manualnej edycji. Projekt obejmuje backend utrzymujący model sesji, statystyki i limity (fiszki, decki, generacje) oraz synchronizację z istniejącym algorytmem spaced repetition przez eksport danych. MVP realizowane jest przez interdyscyplinarny zespół (AI, frontend, backend, produkt/UX) w 10-tygodniowym planie: faza danych, implementacja głównej funkcjonalności, integracja SRS i testy KPI.
## 2. Problem użytkownika
- Wysokiej jakości fiszki wymagają ręcznego dzielenia materiału, formułowania pytań i odpowiedzi oraz uporządkowania treści. Proces ten jest zbyt czasochłonny i zniechęca do stosowania spaced repetition, mimo że metoda ta przynosi mierzalne korzyści w nauce. Użytkownik potrzebuje szybkiego narzędzia, które przy minimalnym wysiłku wygeneruje sensowne fiszki z dowolnego tekstu, jasno pokaże, co jeszcze do zrobienia i pozwoli dopracować gotowe propozycje AI.
## 3. Wymagania funkcjonalne
1. Generowanie fiszek z ciągłego tekstu (kopiuj-wklej) z uwzględnieniem nagłówków, list i akapitów, gdzie model AI proponuje pytanie, odpowiedź, kontekst, tagi i poziom trudności oraz status jakości (Szkic/OK/Dobre).
2. Manualny edytor do korygowania i uzupełniania propozycji AI w trybie inline z szybkim dostępem do akcji batchowych (zatwierdź, odrzuć, zmień tagi/trudność) oraz możliwość tworzenia zupełnie nowych fiszek.
3. Przeglądanie, filtrowanie (tagi, poziom trudności, status), edycja i usuwanie fiszek z widoku listy, przy zachowaniu informacji o źródle (AI/manualne) i możliwością nadpisania tagów/trudności bezpośrednio z listy.
4. Prosty system kont użytkowników z bezpiecznym logowaniem i rozróżnieniem demo vs pełne konto, umożliwiającym przechowywanie sesji, limitów (maks. 2 000 fiszek, 50 decków, 5 generacji dziennie dla zalogowanych, mniejszy limit dla demo) i personalizowanymi sugestiami kolejnych kroków.
5. Mechanizmy progresu: celem sesji vs licznik zaakceptowanych fiszek, propozycje dodania kolejnych jako funkcja długości tekstu i limity sesji.
6. Widoczne limity i komunikaty o wyczerpaniu (interfejs + backendowa walidacja) oraz logika odmowy tworzenia nowych fiszek poza limitem.
7. Eksport całego modelu fiszki (JSON/CSV) ze wszystkimi polami (pytanie, odpowiedź, kontekst, tagi, poziom trudności, status) oraz metadanymi o decku i źródle.
8. Integracja (wysyłka eksportu + proste API) z istniejącym algorytmem powtórek, umożliwiająca synchronizację statusów SRS.
9. Zbieranie KPI za pomocą backendowych eventów (sesja, generacja, edycja, akceptacja), aby mierzyć time-to-value, retencję i odsetek akceptowanych fiszek.
10. System sugerowania tagów i poziomu trudności przez AI z możliwością natychmiastowej edycji przez użytkownika (dropdown/chips) oraz informacją o sugerowanych wartościach.
## 4. Granice produktu
- MVP nie zawiera własnego zaawansowanego algorytmu powtórek typu SuperMemo czy Anki; integracja rozpoczyna się od eksportu danych i prostego API synchronizacji, bez wbudowanego SRS.
- Nie będzie importu wielu formatów (PDF, DOCX, itp.), ograniczamy się do tekstu kopiowanego przez użytkownika.
- Brak współdzielenia zestawów między użytkownikami oraz integracji z zewnętrznymi platformami edukacyjnymi.
- Brak aplikacji mobilnej w MVP (tylko wersja webowa). Limity kontowe rozróżniają demo i pełne konto, ale wszystkie działania odbywają się w jednej aplikacji bez natywnych klient&oacute;w.
- Backend egzekwuje limity (2 000 fiszek, 50 decków, liczba generacji) i KPI, bez konieczności budowy osobnych narzędzi do zarządzania tymi limitami.
## 5. Historyjki użytkowników
- ID: US-001
- Tytuł: Bezpieczne logowanie i rozróżnienie demo vs pełne konto
- Opis: Jako użytkownik chcę się bezpiecznie uwierzytelnić i zobaczyć, czy działam w trybie demo, czy mam pełny dostęp, żeby wiedzieć jakie limity mnie obowiązują i zapewnić poufność moich fiszek.
- Kryteria akceptacji:
  1. Użytkownik może zalogować się lub zalogować jako demo z dwuskładnikową walidacją (np. hasło + token w demo trybie uproszczone).
  2. Po zalogowaniu interfejs wyraźnie pokazuje status konta (demo/pełne) i przypisane limity (fiszki, decki, generacje).
  3. Backend odrzuca żądania przekraczające limity i zwraca opisowy komunikat z informacją o pozostałych zasobach.
  4. Sesje są śledzone jako eventy KPI (data, rodzaj konta, liczba fiszek wygenerowanych podczas sesji).
- ID: US-002
- Tytuł: Generowanie fiszek AI z ciągłego tekstu
- Opis: Jako uczący się chcę wkleić fragment tekstu i otrzymać zestaw fiszek z pytaniami, odpowiedziami, kontekstem, tagami i poziomem trudności oraz heurystycznym statusem jakości, aby szybko rozpocząć sesję nauki.
- Kryteria akceptacji:
  1. Użytkownik wkleja tekst (nagłówki, listy, akapity) i otrzymuje propozycję n fiszek, zorganizowanych według struktury tekstu, bez obsługi tabel.
  2. Każda fiszka zawiera pola: pytanie, odpowiedź, kontekst, tagi, poziom trudności, status (Szkic/OK/Dobre) wygenerowany przez heurystyki.
  3. AI sugeruje tagi/trudność, ale użytkownik może je zmienić bez opuszczania listy (dropdown/chips).
  4. Generacja jest ograniczona do 5 na dzień dla pełnych kont (mniej dla demo) i backend przekazuje komunikat o limicie oraz liczniku pozostałych).
- ID: US-003
- Tytuł: Manualne tworzenie i batchowe edytowanie fiszek
- Opis: Jako użytkownik chcę móc ręcznie stworzyć fiszkę lub dopracować grupę fiszek (akcji batchowych), żeby dostosować treść do swoich potrzeb.
- Kryteria akceptacji:
  1. Użytkownik może wprowadzić nowe pytanie/odpowiedź/kontekst/tagi/trudność oraz zapisać je jako fiszkę ręcznie.
  2. W widoku listy dostępne są akcje batchowe (zatwierdź, oznacz jako OK/Dobre, usuń) i można nimi wybrać wiele fiszek.
  3. Każda edycja zapisuje event KPI, a użytkownik widzi natychmiastowo zmieniony status jakości i liczbę akceptowanych fiszek w postępie sesji.
- ID: US-004
- Tytuł: Przegląd, filtrowanie i usuwanie fiszek
- Opis: Jako użytkownik chcę przeglądać wszystkie fiszki, filtrować po tagach/trudności/statusach oraz usuwać niepotrzebne, żeby utrzymywać porządek i szybko odnaleźć materiał do nauki.
- Kryteria akceptacji:
  1. Lista fiszek pokazuje tagi, poziom trudności, status jakości i Źródło (AI/manualne) oraz umożliwia filtrowanie po tych polach.
  2. Użytkownik może edytować tagi/trudność bez przeładowania (np. dropdown z opcją „dodaj nowy tag”).
  3. Usunięcie fiszki wymaga potwierdzenia i aktualizuje licznik zaakceptowanych fiszek w ramach celu sesji.
- ID: US-005
- Tytuł: Monitorowanie postępu sesji i sugerowane następne kroki
- Opis: Jako uczeń chcę widzieć cel sesji vs licznik zaakceptowanych fiszek oraz sugestie, ile jeszcze stworzyć bazując na długości tekstu, żebym wiedział, jak blisko jestem celu.
- Kryteria akceptacji:
  1. UI pokazuje cel i aktualny licznik dla danej sesji (np. cel 20 fiszek vs 12 zaakceptowanych) oraz czas od początku sesji.
  2. System wylicza docelową liczbę fiszek w funkcji długości tekstu (np. 500 znaków = 1 fiszka) i pokazuje komunikat „dodaj X więcej”.
  3. Po zatwierdzeniu nowej fiszki progress uaktualnia się i event KPI rejestruje zmianę.
- ID: US-006
- Tytuł: Informowanie o statusie jakości fiszki
- Opis: Jako użytkownik chcę widzieć status jakości (Szkic/OK/Dobre) każdego zestawu, żeby wiedzieć, które karty wymagają weryfikacji.
- Kryteria akceptacji:
  1. Heurystyczne algorytmy oceniają długość odpowiedzi, obecność kontekstu i spójność, by przypisać status, a wynik jest widoczny obok fiszki.
  2. Użytkownik może ręcznie zmienić status jakości (np. z Szkic na Dobre) i event KPI odnotowuje zmianę.
  3. System informuje, kiedy status jest Szkic, sugerując dalsze kroki (np. „zweryfikuj odpowiedź”).
- ID: US-007
- Tytuł: Komunikacja i egzekwowanie limitów fiszek i generacji
- Opis: Jako użytkownik chcę wiedzieć ile fiszek/generacji jeszcze mogę wykonać i otrzymywać informację, kiedy limit został osiągnięty, by nie przekroczyć dozwolonej liczby.
- Kryteria akceptacji:
  1. UI pokazuje licznik fiszek i decków w porównaniu do limitów konta oraz ile generacji zostało na dzisiaj.
  2. Próba przekroczenia limitu powoduje blokadę operacji z opisowym komunikatem i zapisem eventu KPI.
  3. Limity są egzekwowane przez backend, który również uwzględnia różnice między kontem demo i pełnym.
- ID: US-008
- Tytuł: Eksport danych fiszek i synchronizacja z algorytmem powtórek
- Opis: Jako użytkownik chcę wyeksportować fiszki w formacie zawierającym cały model (pytanie, odpowiedź, kontekst, tagi, poziom trudności, status), żeby wgrać dane do zewnętrznego algorytmu powtórek.
- Kryteria akceptacji:
  1. Eksport generuje plik JSON lub CSV zawierający wszystkie pola fiszki i identyfikator decku.
  2. Dane eksportu mogą być wysyłane przez proste API do istniejącego SRS i backend potwierdza synchronizację.
  3. Użytkownik otrzymuje potwierdzenie eksportu z informacją, ile fiszek zostało uwzględnionych i kiedy ostatnio synchronizowano.
- ID: US-009
- Tytuł: Sledzenie KPI przez backend
- Opis: Jako zespół produktowy chcemy rejestrować eventy (sesja, generacja AI, edycja, akceptacja), aby mierzyć time-to-value, retencję i poziom akceptacji fiszek AI.
- Kryteria akceptacji:
  1. Każdy event zawiera typ akcji, ID użytkownika lub sesji, źródło fiszki oraz znacznik czasu.
  2. Dane są dostępne do analiz i można obliczyć KPIs (np. % AI-zaakceptowanych fiszek vs liczba generacji).
  3. Backend przesyła eventy także dla zmian limitów oraz wyświetla je jako część raportów dla zespołu produktowego.
## 6. Metryki sukcesu
- 75% fiszek wygenerowanych przez AI jest akceptowanych przez użytkowników (status OK lub Dobre).
- 75% wszystkich fiszek tworzą użytkownicy, wykorzystując AI jako punkt startowy (ilość akcji „zaakceptuj AI propozycję” vs liczba manualnych fiszek bez AI).
- Time-to-value: użytkownik widzi pierwszą zaakceptowaną fiszkę w ramach sesji w mniej niż 5 minut.
- Licznik generacji dziennych: użytkownicy nie przekraczają limitów (5/dzień dla kont pełnych, mniej dla demo) i otrzymują czytelne komunikaty o dostępnych generacjach.
- Retencja tygodniowa: przynajmniej 40% zarejestrowanych użytkowników wraca w ciągu tygodnia do tworzenia lub edycji fiszek.



================================================
FILE: .ai/tech-stack.md
================================================
Tech stack dobrze pokrywa podstawowe wymagania PRD, ale warto wtrącić kilka uwag na poziomie ryzyk i uproszczeń.

## Ocena technologii

- **Szybkość MVP:** Astro + React + TypeScript + Tailwind + shadcn/ui to lekki zestaw umożliwiający szybką budowę interfejsu (punkty 1‑7, 24‑82 PRD). Astro sprzyja prostym stronem, React ograniczamy do interaktywnych komponentów, więc prędkość developmentu jest wysoka. Supabase jako BaaS + Openrouter dla AI + GitHub Actions + DO umożliwiają szybkie wdrożenie MVP w 10 tygodni bez stawiania infrastruktury od zera.

- **Skalowalność:** Supabase (PostgreSQL) i DigitalOcean pozwalają skalować bazę i serwisy (eventy KPI, limity, eksporty). Openrouter umożliwia łatwą zmianę modelu, ale trzeba pilnować limitów i kosztów generacji (US-002, US-009). Przy wzroście użytkowników trzeba monitorować wydajność zapytań (filtry/tagi/statusy) i ewentualnie dodać caching lub kolejkowanie eventów.

- **Koszt utrzymania:** Supabase + Openrouter + DO + GitHub Actions to umiarkowane koszty, ale największy czynnik kosztowy to zapytania do modeli AI. Trzeba ustalić limity, watki użycia i potencjalnie agregować generacje (np. batchowe requesty) by utrzymać koszt w ryzach (US-002, US-007, US-009). Hosting i CI są standardowe i przewidywalne.

- **Złożoność rozwiązania:** Stos jest umiarkowanie złożony – Astro + React to hybryda statyczno‑dynamiczna, więc trzeba pilnować integracji. Możliwe uproszczenie to np. czyste Next.js lub Remix, ale te mogą być cięższe w utrzymaniu na MVP. Supabase dodaje świetną obsługę auth/limits/eventów, więc w praktyce redukuje złożoność backendu. Trzeba tylko dopilnować, że modele KPI, limity, eventy, eksporty i synchronizacja SRS mieszczą się w schemacie danych Supabase.

- **Czy prostsze podejście wystarczy?:** Alternatywa to np. czysto statyczny frontend z Netlify Functions + prosty BaaS (Firebase) oraz bezpośrednie API OpenAI zamiast Openrouter. Zaletą obecnego stacka jest większa kontrola nad eventami, limity użytkowników i SQL‑owe zapytania (filtry/tagi/status) wymagane w PRD, więc prostsze rozwiązanie mogłoby nie dać tych możliwości bez dużego dopisku.

- **Bezpieczeństwo:** Supabase zapewnia auth, demo/pełne role i limity (US-001, US-007). Trzeba zadbać o bezpieczne przechowywanie kluczy (Supabase + Openrouter) i walidację limitów po stronie backendu (backendowy enforcement w PRD). Warto dodać monitoring i alerty dla eventów KPI oraz zabezpieczyć eksport JSON/CSV (US-008). Dla danych użytkowników kluczowe jest szyfrowanie w tranzycie i ograniczenie dostępu do API (rate limiting).

## Podsumowanie
Stack jest zgodny z potrzebami PRD, przy czym należy:
- dokłądnie określić polityki kosztowe dla Openrouter i ewentualnie używać cache lub heurystyk by zredukować liczbę wywołań,
- zaplanować strukturę eventów KPI i limitów w Supabase tak, by spełnić wymagania produktów bez nadmiarowej logiki po stronie serwera,
- zapewnić monitoring i audyty bezpieczeństwa danych i eksportów.

Jeśli potrzebujesz, mogę pomóc zaprojektować konkretną architekturę danych/limitów w Supabase albo schemat integracji z Openrouter. Czy chcesz, żebym rozwinął któryś z tych obszarów?
## Stos technologiczny

### Frontend
- **Astro 5** pozwala tworzyć szybkie strony koncentrujące się na treści, a wbudowane renderowanie po stronie serwera minimalizuje ilość JavaScript.
- **React 19** wykorzystywany jest tylko tam, gdzie potrzebna jest interaktywność (np. edytor fiszek, listy, filtrowanie).
- **TypeScript 5** zwiększa pewność typów i poprawia doświadczenie programistyczne w całym projekcie.
- **Tailwind 4** zapewnia szybkie budowanie spójnego interfejsu przy użyciu klas narzędziowych.
- **Shadcn/ui** dostarcza gotowe komponenty React (dropdowny, chipsy, listy), które skracają wdrożenie złożonych widoków.

### Backend
- **Supabase** udostępnia bazę PostgreSQL, uwierzytelnianie, przechowywanie sesji i logikę limitów bez konieczności budowania własnego serwera.
- Można w nim zakładać RLS, limity kont demo vs pełnych oraz walidować API dla limitów fiszek, decków i generacji.
- Statystyki sesji, KPI i eksport JSON/CSV mogą być trzymane w bazie, a logiczne funkcje (np. licznik generacji) wystarczy napisać raz.

### AI
- **Openrouter.ai** integruje się z wieloma modelami (OpenAI, Anthropic, Google itp.), co pozwala eksperymentować z kosztami i jakością generowanych fiszek.
- Obsługuje centralne zarządzanie kluczami, limity finansowe oraz monitorowanie zużycia, co ułatwia kontrolę kosztów.
- Wszystkie wywołania modeli powinny przebiegać po stronie backendu, aby nie wystawiać kluczy.

### CI/CD i hosting
- **GitHub Actions** automatyzuje testy, budowanie stron Astro i wdrożenie.
- **DigitalOcean + Docker** to środowisko hostujące aplikację, którym można łatwo zarządzać przez obraz kontenera.

Stos łączy szybkie prototypowanie UI z wydajnym backendem i zewnętrznym AI, co pozwala zrealizować MVP zgodnie z PRD w 10-tygodniowym harmonogramie.



================================================
FILE: .ai/ui-plan.md
================================================
# Architektura UI dla AI Flashcards

## 1. Przegląd struktury UI

Aplikacja MVP to webowy interfejs do szybkiego przejścia od wklejenia tekstu do **zaakceptowanych** fiszek (definicja: `quality_status ∈ {ok, good}`), z naciskiem na **review i operacje batch**, czytelne **limity** (demo/full) oraz bezpieczne uwierzytelnienie.

### Założenia IA (Information Architecture)

- Minimalna nawigacja MVP: **5 sekcji**, powiązanych 1:1 z głównymi zasobami API:
  - **Generuj** → `/api/ai/generate`
  - **Fiszki** → `/api/cards`
  - **Decki** → `/api/decks`
  - **Eksport** → `/api/export`
  - **Konto/Status** → `/api/me/status`
- Po udanej generacji (201) aplikacja przenosi użytkownika do **Wyników generacji** filtrowanych po `source_id`, które są głównym miejscem pracy po generacji.
- „Oczekujące” (karty bez `deck_id`) są traktowane jako **preset w widoku Fiszki** („Bez decka”) z kluczową akcją batch „Przypisz do decka”.

### Globalne standardy UX / A11y / Security

- **Server state**: listy i detale z cache, paginacją i invalidacją po mutacjach; szybkie pola z optymistycznymi update’ami (z rollbackiem).
- **Status użytkownika i limity**: `GET /api/me/status` przy starcie sesji; stale widoczny wskaźnik **usage vs limit** + badge **Demo/Full**.
- **Drafty i utrata pracy**: treść wklejona w Generuj przechowywana lokalnie (sessionStorage/localStorage) i odtwarzana po błędach, 401 i nawigacji.
- **Bezpieczeństwo sesji**: tokeny/sesja w bezpiecznych cookie (httpOnly) zgodnie z integracją; UI nie przechowuje sekretów w localStorage.
- **Globalny handler 401**: ciche odświeżenie/logowanie; UI ma zachować lokalne drafty i ponowić akcję, gdy to bezpieczne.
- **Responsywność**: min. 2 breakpointy (mobile/desktop); na mobile filtry w drawer, batch actions jako sticky bottom bar, lista kart jako karty/accordion.
- **Dostępność**:
  - pełna obsługa klawiatury (fokus, selekcja wielokrotna, batch),
  - status jakości nie tylko kolorem (ikona + tekst),
  - poprawne role/ARIA dla toastów i błędów,
  - focus management w modalach i drawerach.

### Główne endpointy API i ich cele (dla zgodności UI)

- `POST /api/ai/generate`: generowanie kart z tekstu, opcjonalnie do `deck_id`; zwraca `source_id`, karty i `remaining_generations`.
- `GET /api/cards`: lista kart z filtrami (`deck_id`, `source_id`, `quality_status`, `tags`, `sort`) + paginacja.
- `POST /api/cards`: tworzenie ręczne (pojedynczo lub w bulk).
- `PATCH /api/cards/:id`: aktualizacja karty (szybkie pola i pełna edycja).
- `PATCH /api/cards/batch`: batch akcje (update status, add tags, delete) + (w UI MVP także „przypisz deck” jako wariant mutacji batch/serii patchy, zależnie od backendu).
- `DELETE /api/cards/:id`: usuwanie karty.
- `GET /api/decks`: lista decków + wyszukiwanie/paginacja.
- `POST /api/decks`: tworzenie decka (limit decków).
- `GET /api/decks/:id`: szczegóły decka.
- `PATCH /api/decks/:id`: edycja decka.
- `DELETE /api/decks/:id`: usunięcie decka (karty przechodzą do `deck_id = null`).
- `GET /api/me/status`: rola, limity i usage.
- `GET /api/export?deck_id=&format=`: eksport danych (json/csv).

## 2. Lista widoków

Poniżej widoki MVP wraz z trasami i elementami. Ścieżki są opisane na poziomie architektury (routing można dostosować do Astro), ale IA pozostaje stała.

### 2.1. Start / Routing wejściowy

- **Nazwa widoku**: Start (Router/Redirect)
- **Ścieżka widoku**: `/`
- **Główny cel**: Szybko skierować użytkownika do właściwego miejsca (Login lub Generuj).
- **Kluczowe informacje do wyświetlenia**:
  - stan sesji (czy zalogowany),
  - skrócone info o produkcie (opcjonalnie).
- **Kluczowe komponenty widoku**:
  - `AuthGate` (sprawdza sesję),
  - `LoadingState` (skeleton/spinner).
- **UX, dostępność i względy bezpieczeństwa**:
  - brak wrażliwych danych,
  - czytelny stan ładowania,
  - nie zapisywać tokenów w storage.

---

### 2.2. Logowanie / Demo

- **Nazwa widoku**: Zaloguj / Kontynuuj jako demo
- **Ścieżka widoku**: `/login`
- **Główny cel**: Uwierzytelnić użytkownika lub uruchomić tryb demo.
- **Kluczowe informacje do wyświetlenia**:
  - wyjaśnienie różnic Demo vs Full (limity i trwałość danych),
  - link do polityki prywatności/zakresu danych (minimalnie informacyjnie).
- **Kluczowe komponenty widoku**:
  - `LoginForm`,
  - `ContinueAsDemoButton`,
  - `AuthErrorBanner`.
- **UX, dostępność i względy bezpieczeństwa**:
  - a11y formularza (label, error summary, fokus na pierwszym błędzie),
  - ochrona przed podwójnym submit (disabled + spinner),
  - brak ujawniania szczegółów błędów auth, które pomagają atakującemu,
  - po sukcesie: przekierowanie do `/generate` i pobranie `GET /api/me/status`.

---

### 2.3. Shell aplikacji (globalny layout)

- **Nazwa widoku**: App Shell (Layout)
- **Ścieżka widoku**: (wspólny layout dla tras chronionych)
- **Główny cel**: Zapewnić spójną nawigację, stały wgląd w status konta/limity i obsługę globalnych stanów.
- **Kluczowe informacje do wyświetlenia**:
  - badge **Demo/Full**,
  - wskaźniki limitów: karty, decki, generacje dzienne,
  - globalne komunikaty (toasty/alerty).
- **Kluczowe komponenty widoku**:
  - `TopBar` / `SideNav` (desktop) i `BottomNav` (mobile),
  - `UsageStatusWidget` (usage vs limit),
  - `GlobalToasts`,
  - `GlobalErrorBoundary`,
  - `ConfirmDialogProvider`.
- **UX, dostępność i względy bezpieczeństwa**:
  - nawigacja klawiaturą (tab order, aria-current),
  - globalna obsługa 401 (z zachowaniem draftów),
  - nie pokazywać danych innych użytkowników (w UI zawsze zakładać, że backend egzekwuje RLS).

---

### 2.4. Generuj (flow krokowy na jednym ekranie)

- **Nazwa widoku**: Generuj
- **Ścieżka widoku**: `/generate`
- **Główny cel**: Wkleić tekst, wybrać/utworzyć deck (opcjonalnie), uruchomić generację i przejść do wyników.
- **Kluczowe informacje do wyświetlenia**:
  - textarea z `content` + licznik znaków (min 50, max 100k),
  - wybór decka lub „Bez decka (Oczekujące)”,
  - bieżące `remaining_generations` i komunikaty limitów,
  - progres generacji i stany (idle/loading/success/error).
- **Kluczowe komponenty widoku**:
  - `GenerateTextInput` (z autosave do storage),
  - `DeckPicker` (z opcją “Bez decka”),
  - `CreateDeckModal` (tworzenie „w locie”),
  - `GenerateSubmitButton`,
  - `GenerateProgressPanel` (loader + copy),
  - `LimitBanner` (dla 429 i prewencyjnych blokad).
- **UX, dostępność i względy bezpieczeństwa**:
  - zachowanie treści draftu przy nawigacji i błędach,
  - przy 429: jasny komunikat, ile pozostało i kiedy odblokuje (jeśli dostępne),
  - walidacja client-side + niezależna walidacja backend,
  - nie ujawniać pełnej treści błędów serwera; zapewnić „pokaż szczegóły” dla debug (opcjonalnie).

---

### 2.5. Wyniki generacji (główna praca po generacji)

- **Nazwa widoku**: Wyniki generacji
- **Ścieżka widoku**: `/generate/results?source_id=:sourceId` (lub `/sources/:sourceId/results`)
- **Główny cel**: Przejrzeć i zaakceptować/ulepszyć wygenerowane fiszki dla danego `source_id`.
- **Kluczowe informacje do wyświetlenia**:
  - lista kart z `source_id` (domyślnie `quality_status='draft'`, ale z możliwością filtrowania),
  - panel „Źródło” z oryginalnym tekstem (readonly) lub wycinkiem,
  - licznik zaakceptowanych vs cel (cel per `source_id`),
  - szybkie akcje inline i batch: status/tagi/usuwanie,
  - CTA „Zobacz wszystkie fiszki”.
- **Kluczowe komponenty widoku**:
  - `SourcePanel` (readonly, collapsible),
  - `SessionGoalWidget` (ustaw cel i licz postęp),
  - `CardsList` (filtrowana po `source_id`),
  - `CardRow` / `CardCard` (mobile) z szybkim edytowaniem: tagi, trudność, status,
  - `BatchSelectionToolbar` (desktop) / `StickyBatchBar` (mobile),
  - `BatchUpdateStatusAction` (primary: „Oznacz jako OK/Dobre”),
  - `BatchAddTagsAction`,
  - `BatchDeleteAction` + potwierdzenie,
  - `OpenCardDetails` (pełna edycja: panel boczny lub osobny widok – patrz 2.7),
  - `GoToCardsCTA`.
- **UX, dostępność i względy bezpieczeństwa**:
  - batch selection dostępny klawiaturą (checkboxy + skróty, np. Shift+Click / Shift+Arrow),
  - status jakości zawsze jako tekst + ikona,
  - context domyślnie zwinięty, z kontrolą „Pokaż kontekst”,
  - ostrożne komunikaty przy usuwaniu (undo tylko jeśli backend wspiera; w MVP potwierdzenie),
  - obsługa 401/403/404 dla `source_id` (bez wycieku informacji).

---

### 2.6. Fiszki (globalna lista + presety, filtry i batch)

- **Nazwa widoku**: Fiszki
- **Ścieżka widoku**: `/cards`
- **Główny cel**: Przeglądać wszystkie fiszki, filtrować/sortować, wykonywać szybkie zmiany inline i operacje batch.
- **Kluczowe informacje do wyświetlenia**:
  - lista kart z paginacją,
  - filtry 1:1 z API: `deck_id`, `source_id`, `quality_status`, `tags`, `sort`,
  - preset „Bez decka (Oczekujące)” = `deck_id = null`,
  - źródło (AI/manual), data utworzenia/edycji (jeśli dostępne),
  - wskaźnik limitu kart (ile pozostało do 2000).
- **Kluczowe komponenty widoku**:
  - `CardsFiltersPanel` (desktop) / `FiltersDrawer` (mobile),
  - `SavedPresets` (np. „Oczekujące”, „Drafty”, „Zaakceptowane”),
  - `CardsTable` (desktop) / `CardsAccordion` (mobile),
  - inline edit dla: `tags`, `difficulty`, `quality_status`,
  - `BatchSelectionToolbar` / `StickyBatchBar`,
  - batch akcje:
    - `BatchUpdateStatusAction` (primary),
    - `BatchAddTagsAction`,
    - `BatchDeleteAction`,
    - `BatchAssignToDeckAction` (kluczowe dla „Oczekujące”),
  - `CreateCardModal` (manualne tworzenie) lub CTA do tworzenia w osobnym kroku (MVP: modal).
- **UX, dostępność i względy bezpieczeństwa**:
  - filtry odzwierciedlone w URL (query string) dla share/bookmark,
  - tryb „Oczekujące” wyraźnie komunikuje brak decka i oferuje „Przypisz do decka” jako primary,
  - potwierdzenie przed usunięciem (i czytelne skutki),
  - a11y: drawer filtrów i sticky bar z poprawnym fokusowaniem,
  - odporność na duże listy (paginacja, skeletony, empty states).

---

### 2.7. Szczegóły / Pełna edycja fiszki (rozwiązanie otwarte)

- **Nazwa widoku**: Szczegóły fiszki (pełna edycja)
- **Ścieżka widoku**:
  - wariant A (deep-linking): `/cards/:id`
  - wariant B (panel boczny): jako overlay w `/cards` i `/generate/results` z parametrem `?card_id=:id`
- **Główny cel**: Pełna edycja pól: pytanie/odpowiedź/kontekst + metadane.
- **Kluczowe informacje do wyświetlenia**:
  - pełne pola: `question`, `answer`, `context`,
  - `deck_id`, `tags`, `difficulty`, `quality_status`,
  - info o źródle: `source_id` i link do wyników generacji (jeśli dotyczy).
- **Kluczowe komponenty widoku**:
  - `CardEditorForm`,
  - `CardPreview` (front/back),
  - `ContextEditor` (z podpowiedzią formatowania),
  - `TagInputAutocomplete` (normalizacja trim + opcjonalny lowercase, limit tagów/kartę),
  - `SaveBar` (sticky) + `Cancel`.
- **UX, dostępność i względy bezpieczeństwa**:
  - zarządzanie fokusem (otwarcie/zamknięcie overlay, powrót fokusu),
  - ostrzeżenie o niezapisanych zmianach,
  - brak ujawniania danych przy 404/403,
  - decyzja produktowa: panel boczny lepszy dla „ciągłości pracy”, osobna strona lepsza dla deep-linking i mobile a11y.

---

### 2.8. Decki (lista)

- **Nazwa widoku**: Decki
- **Ścieżka widoku**: `/decks`
- **Główny cel**: Zarządzać kolekcjami: tworzyć/edytować/usuwać decki oraz wejść do szczegółów.
- **Kluczowe informacje do wyświetlenia**:
  - lista decków + wyszukiwanie,
  - licznik decków vs limit,
  - podstawowe metadane (nazwa, opis, data).
- **Kluczowe komponenty widoku**:
  - `DecksList` (paginacja),
  - `CreateDeckButton` + `CreateDeckModal`,
  - `DeckRowActions` (edytuj/usuń),
  - `LimitBanner` (gdy limit decków osiągnięty).
- **UX, dostępność i względy bezpieczeństwa**:
  - potwierdzenie przed usunięciem decka z jasnym skutkiem: karty przechodzą do „Bez decka”,
  - blokada tworzenia przy limicie (prewencyjna + backend),
  - a11y dla modalów i menu akcji.

---

### 2.9. Deck – szczegóły

- **Nazwa widoku**: Szczegóły decka
- **Ścieżka widoku**: `/decks/:id`
- **Główny cel**: Przeglądać deck oraz przejść do fiszek w tym decku i eksportu.
- **Kluczowe informacje do wyświetlenia**:
  - nazwa i opis,
  - CTA „Pokaż fiszki” (link do `/cards?deck_id=:id`),
  - CTA „Eksportuj ten deck”.
- **Kluczowe komponenty widoku**:
  - `DeckHeader`,
  - `DeckActions` (edytuj/usuń),
  - `DeckShortcuts` (fiszki, eksport).
- **UX, dostępność i względy bezpieczeństwa**:
  - obsługa 404/403 (deck nie istnieje lub nie należy do usera),
  - jasne komunikaty o skutkach usunięcia decka.

---

### 2.10. Eksport

- **Nazwa widoku**: Eksport
- **Ścieżka widoku**: `/export`
- **Główny cel**: Wybrać zakres i format eksportu, potwierdzić i pobrać plik.
- **Kluczowe informacje do wyświetlenia**:
  - zakres: „Wszystkie fiszki” albo „Wybrany deck”,
  - format: `json` / `csv`,
  - potwierdzenie zakresu danych,
  - wynik: ile kart i kiedy wykonano eksport (jeśli dostępne).
- **Kluczowe komponenty widoku**:
  - `ExportScopeSelector`,
  - `DeckSelect` (dla zakresu deck),
  - `FormatSelector`,
  - `ExportConfirmDialog`,
  - `DownloadButton`,
  - `ExportResultSummary`.
- **UX, dostępność i względy bezpieczeństwa**:
  - wyraźne potwierdzenie (eksport danych prywatnych),
  - ograniczenie wielokrotnych kliknięć i pokazanie postępu,
  - obsługa błędów sieci / 401 / 429 (jeśli dotyczy).

---

### 2.11. Konto / Status

- **Nazwa widoku**: Konto / Status
- **Ścieżka widoku**: `/account`
- **Główny cel**: Pokazać status konta, limity i stan wykorzystania; zapewnić podstawowe akcje konta.
- **Kluczowe informacje do wyświetlenia**:
  - rola: demo/full,
  - usage vs limit (karty, decki, generacje),
  - wskazówki „co dalej” (np. „Wyczerpałeś generacje – wróć jutro”).
- **Kluczowe komponenty widoku**:
  - `AccountBadge`,
  - `LimitsPanel`,
  - `UsageHistoryHint` (opcjonalnie, bez rozbudowanej analityki w MVP),
  - `LogoutButton`.
- **UX, dostępność i względy bezpieczeństwa**:
  - brak wrażliwych danych poza limitami,
  - obsługa 401 jako przekierowanie do `/login`,
  - jasne komunikaty limitów (szczególnie 429).

## 3. Mapa podróży użytkownika

### 3.1. Główny przypadek użycia (Time-to-value): Generuj → Wyniki → Akceptacja

1. **Wejście**
   - Użytkownik wchodzi na `/`.
   - Jeśli brak sesji → `/login`; jeśli jest sesja → `/generate`.
2. **Login/Demo**
   - Użytkownik loguje się lub wybiera demo.
   - Aplikacja pobiera `GET /api/me/status` i zapisuje w server state.
3. **Generuj**
   - Wkleja tekst, widzi liczniki i walidację (min 50, max 100k).
   - Wybiera deck z listy (z `GET /api/decks`) albo wybiera „Bez decka (Oczekujące)”.
   - Opcjonalnie: tworzy deck w modalu (`POST /api/decks`) bez utraty wklejonego tekstu.
4. **Uruchom generację**
   - Klik „Generuj” → `POST /api/ai/generate`.
   - UI pokazuje progres i blokuje wielokrotne wysłania.
   - Jeśli 201 → nawigacja do `/generate/results?source_id=...`.
   - Jeśli 429 → pozostaje na `/generate`, pokazuje komunikat limitu i zachowuje draft.
5. **Wyniki generacji**
   - UI pobiera listę kart dla `source_id` przez `GET /api/cards?source_id=...`.
   - Użytkownik ustawia cel sesji dla `source_id` (lokalnie w UI, per source).
   - Użytkownik selekcjonuje wiele kart i wykonuje batch update statusu przez `PATCH /api/cards/batch` (primary).
   - Postęp (zaakceptowane vs cel) aktualizuje się w UI natychmiast.
   - Użytkownik może dodać tagi batch, zmienić trudność inline (patch per karta) i usunąć niechciane karty (batch lub delete).
6. **Kontynuacja**
   - CTA „Zobacz wszystkie fiszki” prowadzi do `/cards?source_id=...` (lub do `/cards` z presetem).
   - Użytkownik może przejść do organizacji „Oczekujących” (jeśli generował bez decka) i przypisać je do decka.

### 3.2. Alternatywne ścieżki

- **Organizacja po generacji**: Wyniki → /cards (preset „Bez decka”) → batch „Przypisz do decka” → /decks/:id.
- **Manualne tworzenie**: /cards → „Dodaj fiszkę” → `POST /api/cards` → odświeżenie listy i liczników limitów.
- **Eksport**: /decks/:id → skrót „Eksportuj” → /export z wstępnie wybranym deckiem → `GET /api/export?...`.

## 4. Układ i struktura nawigacji

### 4.1. Struktura

- **Nawigacja główna (5 sekcji)**:
  - `/generate` (Generuj)
  - `/cards` (Fiszki)
  - `/decks` (Decki)
  - `/export` (Eksport)
  - `/account` (Konto/Status)
- **Nawigacja kontekstowa**:
  - z Wyników: CTA do `/cards` (globalna lista) + powrót do `/generate`,
  - z Decka: CTA do `/cards?deck_id=:id` i do `/export?deck_id=:id` (jako prefill).

### 4.2. Wzorce responsywne

- **Desktop**: topbar + side nav; filtry jako panel boczny.
- **Mobile**: bottom nav; filtry jako drawer; batch actions jako sticky bottom bar.

### 4.3. Zasady ochrony tras

- Trasy aplikacji (poza `/login` i ewentualnymi publicznymi stronami informacyjnymi) są chronione przez `AuthGate`.
- Przy 401: automatyczna próba odświeżenia sesji; jeśli nieudana → `/login` z zachowaniem draftów Generuj.

## 5. Kluczowe komponenty

- **`AuthGate` / `AuthBoundary`**: ochrona tras, obsługa 401, przywracanie użytkownika po loginie.
- **`UsageStatusWidget`**: stały komponent pokazujący role (demo/full) i limity/usage (źródło prawdy: `GET /api/me/status`).
- **`LimitBanner`**: spójne komunikaty o limitach (w tym 429) i prewencyjne blokady UI.
- **`DeckPicker` + `CreateDeckModal`**: wybór decka i tworzenie „w locie” bez utraty draftu.
- **`CardsList` / `CardsTable` / `CardsAccordion`**: wspólny silnik listowania kart z paginacją i stanami (loading/empty/error).
- **`CardsFiltersPanel` / `FiltersDrawer`**: filtry 1:1 z query paramami `/api/cards`.
- **`BatchSelectionToolbar` / `StickyBatchBar`**: operacje batch (status/tagi/usuwanie/przypisanie do decka) z pełnym wsparciem klawiatury.
- **`QualityStatusBadge`**: jednolite mapowanie statusów jakości i „akceptacji” (ok/good = zaakceptowane).
- **`TagInputAutocomplete`**: autocomplete tagów per-user, normalizacja (trim + opcjonalny lowercase), limit tagów/kartę.
- **`CardQuickEdit`**: szybkie pola inline (tagi/trudność/status) z optymistycznym update.
- **`CardDetailsEditor`**: pełna edycja (drawer lub strona) z ostrzeżeniem o niezapisanych zmianach.
- **`ConfirmDialog`**: wymagany dla delete oraz eksportu (zakres danych).
- **`GlobalToasts` + `InlineError`**: spójna komunikacja błędów (network, walidacja, 429).

---

## Mapowanie historyjek użytkownika (PRD) do architektury UI

- **US-001 (Login + demo/full + limity)**:
  - Widoki: `/login`, `/account`, App Shell.
  - UI: badge Demo/Full, `UsageStatusWidget`, komunikaty limitów.
- **US-002 (Generowanie AI z tekstu)**:
  - Widok: `/generate` → `/generate/results`.
  - UI: textarea z walidacją, deck picker, progres generacji, obsługa 429.
- **US-003 (Manualne tworzenie + batch edycje)**:
  - Widok: `/cards`, `/generate/results`, (szczegóły `/cards/:id`).
  - UI: selekcja, batch toolbar, inline edit, modal „Dodaj fiszkę”.
- **US-004 (Przegląd/filtrowanie/usuwanie)**:
  - Widok: `/cards`.
  - UI: filtry (tagi/trudność/status), potwierdzenie usunięcia, inline edit.
- **US-005 (Progres i sugestie kolejnych kroków)**:
  - Widok: `/generate/results`.
  - UI: `SessionGoalWidget`, licznik zaakceptowanych vs cel, komunikaty „dodaj X więcej”.
- **US-006 (Status jakości fiszki)**:
  - Widoki: `/generate/results`, `/cards`, `/cards/:id`.
  - UI: `QualityStatusBadge`, możliwość ręcznej zmiany statusu (inline i batch).
- **US-007 (Limity fiszek i generacji)**:
  - Widoki: globalnie w App Shell + krytycznie `/generate`, `/decks`, `/cards`.
  - UI: prewencyjne blokady (disable CTA), `LimitBanner`, komunikaty backendowe (429/400).
- **US-008 (Eksport + potwierdzenie)**:
  - Widok: `/export` (+ skróty w `/decks/:id`).
  - UI: wybór zakresu/formatu, potwierdzenie, podsumowanie eksportu.
- **US-009 (KPI tracking)**:
  - UI: brak osobnych ekranów; architektura uwzględnia spójne momenty akcji (login/generacja/edycja/akceptacja/eksport) oraz definicję „akceptacji” opartą o `quality_status`.

---

## Przypadki brzegowe i stany błędów (wspólne standardy)

- **401 Unauthorized**: globalny handler; zachowanie draftu Generuj; po ponownym logowaniu powrót do poprzedniego widoku.
- **403 Forbidden / 404 Not Found**: jednolite ekrany „Brak dostępu” / „Nie znaleziono”; bez wycieku informacji o cudzych zasobach.
- **429 Too Many Requests**:
  - Generacje: blokada „Generuj”, komunikat z pozostałym limitem (`remaining_generations`) i sugestią.
  - Limity kart/decków: blokady CTA + link do /account z wyjaśnieniem.
- **Walidacja 400**: błędy per pole + summary; nie gubić danych formularzy.
- **Błąd sieci / 500**: retry, komunikat, zachowanie stanu selekcji/batch (o ile możliwe), brak utraty draftów.
- **Usunięcie decka**: karty przechodzą do „Bez decka”; UI pokazuje toast i link do presetu „Oczekujące”.
- **Duże listy (wydajność)**: paginacja, skeletony, ograniczenie odświeżeń, brak fetch na każde wpisanie (debounce dla filtrów).




================================================
FILE: .ai/view-implementation-plan.md
================================================
<analysis>
1. Kluczowe punkty specyfikacji API:
   - Endpoint: POST `/api/ai/generate` uruchamia pipeline AI.
   - Logika: sprawdza limity dzienne w `user_usage_stats`, tworzy rekord `sources`, wywołuje OpenRouter, parsuje odpowiedź, zapisuje `cards` z `quality_status='draft'`, loguje KPI (`ai_generation`) i zwraca `source_id`, listę kart oraz pozostałe limity.
2. Parametry:
   - Wymagane: `content` (string, min 50, max 100000).
   - Opcjonalne: `deck_id` (uuid).
3. Niezbędne typy DTO/Command:
   - `GenerateCardsCommand`, `GenerateCardsResponseDto`, `GeneratedCardDto`, `CardQualityStatus`, `DbSource["id"]`, `DbDeck["id"]`.
4. Ekstrakcja logiki do service:
   - Nowy serwis `src/lib/services/ai-generation.service.ts` (lub istniejący jeśli jest): walidacja limitów, utworzenie `sources`, wywołanie OpenRouter, mapowanie do kart, zapis w `cards`, KPI.
5. Walidacja:
   - Zod schema zgodna z planem API i ograniczeniami DB (`content` długość, `deck_id` UUID, atrybuty kart w zakresach).
6. Rejestrowanie błędów:
   - Brak dedykowanej tabeli błędów w schemacie; użyć logowania serwerowego + opcjonalnie KPI `event_type='ai_generation_failed'` z metadanymi.
7. Zagrożenia bezpieczeństwa:
   - Nadużycia limitów (rate limiting/limit dzienny), wstrzyknięcia/nieprawidłowe dane, wycieki kluczy OpenRouter, dostęp do zasobów innych użytkowników (RLS).
8. Scenariusze błędów i kody:
   - 400: błędne dane wejściowe, walidacja Zod.
   - 401: brak/nieprawidłowy JWT.
   - 404: deck nie istnieje lub nie należy do użytkownika (gdy podano `deck_id`).
   - 429: limit dzienny generacji przekroczony.
   - 500: błąd AI/DB/parsing.
</analysis>

# API Endpoint Implementation Plan: POST /api/ai/generate

## 1. Przegląd punktu końcowego
Endpoint generuje fiszki z podanego tekstu przy użyciu AI. Sprawdza limity użytkownika, zapisuje źródło, generuje i zapisuje karty jako szkice (`quality_status='draft'`), loguje KPI i zwraca wygenerowane karty wraz z pozostałym limitem dziennym.

## 2. Szczegóły żądania
- Metoda HTTP: `POST`
- Struktura URL: `/api/ai/generate`
- Parametry:
  - Wymagane: `content` (string, 50–100000 znaków)
  - Opcjonalne: `deck_id` (uuid)
- Request Body:
  ```json
  {
    "content": "string",
    "deck_id": "uuid (optional)"
  }
  ```

## 3. Wykorzystywane typy
- `GenerateCardsCommand`
- `GenerateCardsResponseDto`
- `GeneratedCardDto`
- `CardQualityStatus`

## 3. Szczegóły odpowiedzi
- Kod sukcesu: `201 Created`
- Response Body:
  ```json
  {
    "source_id": "uuid",
    "cards": [
      {
        "id": "uuid",
        "front": "string",
        "back": "string",
        "context": "string",
        "difficulty": 3,
        "tags": ["string"],
        "quality_status": "draft"
      }
    ],
    "remaining_generations": 3
  }
  ```

## 4. Przepływ danych
1. Middleware uwierzytelnia użytkownika (Supabase Auth, JWT).
2. Handler odczytuje `content` i opcjonalny `deck_id`.
3. Walidacja Zod: długość `content`, UUID `deck_id`.
4. Serwis `ai-generation`:
   - Pobiera profil i rolę (`profiles.account_role`).
   - Weryfikuje limity w `user_usage_stats` dla bieżącej daty (UTC). Jeśli brak rekordu, tworzy go.
   - Jeśli `deck_id` podany, weryfikuje istnienie decka i własność użytkownika.
   - Tworzy rekord `sources` z `content`, `character_count`, `user_id` i tytułem (np. skrót treści).
   - Wywołuje OpenRouter z `content` i mapuje wynik na karty.
   - Wstawia `cards` z `quality_status='draft'` i referencjami do `source_id` i `deck_id`.
   - Aktualizuje `user_usage_stats.generation_count` atomowo.
   - Zapisuje KPI w `kpi_events` (`event_type='ai_generation'`, metadata: liczba kart, koszt).
5. Handler mapuje `question/answer` → `front/back` i zwraca `GenerateCardsResponseDto`.

## 5. Względy bezpieczeństwa
- Wymagane uwierzytelnienie (JWT) i RLS (`auth.uid()`).
- Walidacja `deck_id` pod kątem własności użytkownika.
- Ochrona kluczy OpenRouter po stronie backendu.
- Limit dzienny generacji i potencjalny rate limiting.
- Sanitizacja i limity długości wejścia (DoS/abuse).

## 6. Obsługa błędów
- `400 Bad Request`: niepoprawny format body, `content` zbyt krótki/długi, niepoprawny UUID.
- `401 Unauthorized`: brak/nieprawidłowy JWT.
- `404 Not Found`: deck nie istnieje lub nie należy do użytkownika.
- `429 Too Many Requests`: przekroczony limit dzienny generacji.
- `500 Internal Server Error`: błąd OpenRouter, błąd zapisu w DB, błąd parsowania odpowiedzi.
- Logowanie: error log + opcjonalny KPI `ai_generation_failed` z metadanymi (brak dedykowanej tabeli błędów).

## 7. Wydajność
- Stosować pojedyncze inserty bulk dla kart.
- Unikać nadmiarowych zapytań (pobrać profil i stats w jednej transakcji).
- Indeksy: `cards(user_id)`, `cards(source_id)`, `user_usage_stats(date)` wspierają zapytania.
- Zadbaj o timeout i retry politykę dla OpenRouter.

## 8. Kroki implementacji
1. Utwórz Zod schema dla `GenerateCardsCommand`.
2. Dodaj endpoint `src/pages/api/ai/generate.ts` z `export const prerender = false`.
3. Użyj `context.locals.supabase` do zapytań (zgodnie z regułami backend).
4. Utwórz serwis `src/lib/services/ai-generation.service.ts`:
   - `checkAndIncrementDailyLimit(userId, role)`
   - `createSource(userId, content)`
   - `generateCardsWithAI(content)`
   - `insertGeneratedCards(userId, sourceId, deckId, cards)`
   - `logKpiEvent(userId, 'ai_generation', metadata)`
5. Zaimplementuj walidację decka (jeśli `deck_id`).
6. Zaimplementuj mapowanie AI → `CardCreateCommand` i zapis w `cards`.
7. Zwróć `GenerateCardsResponseDto` z przemapowaniem pól `front/back`.
8. Dodaj obsługę błędów i spójne kody statusu (400/401/404/429/500).



================================================
FILE: .cursor/rules/api-supabase-astro-init.mdc
================================================
---
description: 
globs: 
alwaysApply: false
---
# Supabase Astro Initialization

This document provides a reproducible guide to create the necessary file structure for integrating Supabase with your Astro project.

## Prerequisites

- Your project should use Astro 5, TypeScript 5, React 19, and Tailwind 4.
- Install the `@supabase/supabase-js` package.
- Ensure that `/supabase/config.toml` exists
- Ensure that a file `/src/db/database.types.ts` exists and contains the correct type definitions for your database.

IMPORTANT: Check prerequisites before perfoming actions below. If they're not met, stop and ask a user for the fix.

## File Structure and Setup

### 1. Supabase Client Initialization

Create the file `/src/db/supabase.client.ts` with the following content:

```ts
import { createClient } from '@supabase/supabase-js';

import type { Database } from '../db/database.types.ts';

const supabaseUrl = import.meta.env.SUPABASE_URL;
const supabaseAnonKey = import.meta.env.SUPABASE_KEY;

export const supabaseClient = createClient<Database>(supabaseUrl, supabaseAnonKey);
```

This file initializes the Supabase client using the environment variables `SUPABASE_URL` and `SUPABASE_KEY`.


### 2. Middleware Setup

Create the file `/src/middleware/index.ts` with the following content:

```ts
import { defineMiddleware } from 'astro:middleware';

import { supabaseClient } from '../db/supabase.client.ts';

export const onRequest = defineMiddleware((context, next) => {
  context.locals.supabase = supabaseClient;
  return next();
});
```

This middleware adds the Supabase client to the Astro context locals, making it available throughout your application.


### 3. TypeScript Environment Definitions

Create the file `src/env.d.ts` with the following content:

```ts
/// <reference types="astro/client" />

import type { SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './db/database.types.ts';

declare global {
  namespace App {
    interface Locals {
      supabase: SupabaseClient<Database>;
    }
  }
}

interface ImportMetaEnv {
  readonly SUPABASE_URL: string;
  readonly SUPABASE_KEY: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

This file augments the global types to include the Supabase client on the Astro `App.Locals` object, ensuring proper typing throughout your application.



================================================
FILE: .cursor/rules/astro.mdc
================================================
---
description: 
globs: *.astro
alwaysApply: false
---
### Guidelines for Astro

- Leverage View Transitions API for smooth page transitions (use ClientRouter)
- Use content collections with type safety for blog posts, documentation, etc.
- Leverage Server Endpoints for API routes
- Use POST, GET  - uppercase format for endpoint handlers
- Use `export const prerender = false` for API routes
- Use zod for input validation in API routes
- Extract logic into services in `src/lib/services`
- Implement middleware for request/response modification
- Use image optimization with the Astro Image integration
- Implement hybrid rendering with server-side rendering where needed
- Use Astro.cookies for server-side cookie management
- Leverage import.meta.env for environment variables



================================================
FILE: .cursor/rules/backend.mdc
================================================
---
description: 
globs: src/db/*.ts,src/middleware/*.ts,src/lib/*.ts
alwaysApply: false
---
### Backend and Database

- Use Supabase for backend services, including authentication and database interactions.
- Follow Supabase guidelines for security and performance.
- Use Zod schemas to validate data exchanged with the backend.
- Use supabase from context.locals in Astro routes instead of importing supabaseClient directly
- Use SupabaseClient type from `src/db/supabase.client.ts`, not from `@supabase/supabase-js`


================================================
FILE: .cursor/rules/db-supabase-migrations.mdc
================================================
---
description: 
globs: 
alwaysApply: false
---
# Database: Create migration

You are a Postgres Expert who loves creating secure database schemas.

This project uses the migrations provided by the Supabase CLI.

## Creating a migration file

Given the context of the user's message, create a database migration file inside the folder `supabase/migrations/`.

The file MUST following this naming convention:

The file MUST be named in the format `YYYYMMDDHHmmss_short_description.sql` with proper casing for months, minutes, and seconds in UTC time:

1. `YYYY` - Four digits for the year (e.g., `2024`).
2. `MM` - Two digits for the month (01 to 12).
3. `DD` - Two digits for the day of the month (01 to 31).
4. `HH` - Two digits for the hour in 24-hour format (00 to 23).
5. `mm` - Two digits for the minute (00 to 59).
6. `ss` - Two digits for the second (00 to 59).
7. Add an appropriate description for the migration.

For example:

```
20240906123045_create_profiles.sql
```


## SQL Guidelines

Write Postgres-compatible SQL code for Supabase migration files that:

- Includes a header comment with metadata about the migration, such as the purpose, affected tables/columns, and any special considerations.
- Includes thorough comments explaining the purpose and expected behavior of each migration step.
- Write all SQL in lowercase.
- Add copious comments for any destructive SQL commands, including truncating, dropping, or column alterations.
- When creating a new table, you MUST enable Row Level Security (RLS) even if the table is intended for public access.
- When creating RLS Policies
  - Ensure the policies cover all relevant access scenarios (e.g. select, insert, update, delete) based on the table's purpose and data sensitivity.
  - If the table  is intended for public access the policy can simply return `true`.
  - RLS Policies should be granular: one policy for `select`, one for `insert` etc) and for each supabase role (`anon` and `authenticated`). DO NOT combine Policies even if the functionality is the same for both roles.
  - Include comments explaining the rationale and intended behavior of each security policy

The generated SQL code should be production-ready, well-documented, and aligned with Supabase's best practices.



================================================
FILE: .cursor/rules/frontend.mdc
================================================
---
description: 
globs: *.tsx,*.astro
alwaysApply: false
---
## Frontend

### General Guidelines

- Use Astro components (.astro) for static content and layout
- Implement framework components in React only when interactivity is needed

### Guidelines for Styling

#### Tailwind

- Use the @layer directive to organize styles into components, utilities, and base layers
- Use arbitrary values with square brackets (e.g., w-[123px]) for precise one-off designs
- Implement the Tailwind configuration file for customizing theme, plugins, and variants
- Leverage the theme() function in CSS for accessing Tailwind theme values
- Implement dark mode with the dark: variant
- Use responsive variants (sm:, md:, lg:, etc.) for adaptive designs
- Leverage state variants (hover:, focus-visible:, active:, etc.) for interactive elements

### Guidelines for Accessibility

#### ARIA Best Practices

- Use ARIA landmarks to identify regions of the page (main, navigation, search, etc.)
- Apply appropriate ARIA roles to custom interface elements that lack semantic HTML equivalents
- Set aria-expanded and aria-controls for expandable content like accordions and dropdowns
- Use aria-live regions with appropriate politeness settings for dynamic content updates
- Implement aria-hidden to hide decorative or duplicative content from screen readers
- Apply aria-label or aria-labelledby for elements without visible text labels
- Use aria-describedby to associate descriptive text with form inputs or complex elements
- Implement aria-current for indicating the current item in a set, navigation, or process
- Avoid redundant ARIA that duplicates the semantics of native HTML elements


================================================
FILE: .cursor/rules/react.mdc
================================================
---
description: 
globs: *.tsx
alwaysApply: false
---
### Guidelines for React

- Use functional components with hooks instead of class components
- Never use "use client" and other Next.js directives as we use React with Astro
- Extract logic into custom hooks in `src/components/hooks`
- Implement React.memo() for expensive components that render often with the same props
- Utilize React.lazy() and Suspense for code-splitting and performance optimization
- Use the useCallback hook for event handlers passed to child components to prevent unnecessary re-renders
- Prefer useMemo for expensive calculations to avoid recomputation on every render
- Implement useId() for generating unique IDs for accessibility attributes
- Consider using the new useOptimistic hook for optimistic UI updates in forms
- Use useTransition for non-urgent state updates to keep the UI responsive


================================================
FILE: .cursor/rules/shared.mdc
================================================
---
description: 
globs: 
alwaysApply: true
---
# AI Rules for {app-name}

{project-description}

## Tech Stack

- Astro 5
- TypeScript 5
- React 19
- Tailwind 4
- Shadcn/ui

## Project Structure

When introducing changes to the project, always follow the directory structure below:

- `./src` - source code
- `./src/layouts` - Astro layouts
- `./src/pages` - Astro pages
- `./src/pages/api` - API endpoints
- `./src/middleware/index.ts` - Astro middleware
- `./src/db` - Supabase clients and types
- `./src/types.ts` - Shared types for backend and frontend (Entities, DTOs)
- `./src/components` - Client-side components written in Astro (static) and React (dynamic)
- `./src/components/ui` - Client-side components from Shadcn/ui
- `./src/lib` - Services and helpers 
- `./src/assets` - static internal assets
- `./public` - public assets

When modifying the directory structure, always update this section.

## Coding practices

### Guidelines for clean code

- Use feedback from linters to improve the code when making changes.
- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deeply nested if statements.
- Place the happy path last in the function for improved readability.
- Avoid unnecessary else statements; use if-return pattern instead.
- Use guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Consider using custom error types or error factories for consistent error handling.



================================================
FILE: .cursor/rules/ui-shadcn-helper.mdc
================================================
---
description: 
globs: 
alwaysApply: false
---
# Shadcn UI Components

Ten projekt wykorzystuje @shadcn/ui dla komponentów interfejsu użytkownika. Są to pięknie zaprojektowane, dostępne komponenty, które można dostosować do swojej aplikacji.

## Odszukiwanie zainstalowanych komponentów

Komponenty są dostępne w folderze `src/components/ui`, zgodnie z aliasami z pliku `components.json`

## Wykorzystanie komponentu

Zaimportuj komponent zgodnie ze skonfigurowanym aliasem `@/`

```tsx
import { Button } from "@/components/ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
```

Przykładowe wykorzsytanie komponnetów:

```tsx
<Button variant="outline">Click me</Button>

<Card>
  <CardHeader>
    <CardTitle>Card Title</CardTitle>
    <CardDescription>Card Description</CardDescription>
  </CardHeader>
  <CardContent>
    <p>Card Content</p>
  </CardContent>
  <CardFooter>
    <p>Card Footer</p>
  </CardFooter>
</Card>
```

## Instalowanie dodatkowych komponentów

Wiele innych komponentów jest dostępnych, ale nie są one obecnie zainstalowane. Pełną listę można znaleźć na stronie https://ui.shadcn.com/r

Aby zainstalować nowy komponent, wykorzystaj shadcn CLI


```bash
npx shadcn@latest add [component-name]
```

Przykładowo, aby dodać komponent accordion

```bash
npx shadcn@latest add accordion
```

Ważne: `npx shadcn-ui@latest` zostało wycofane, korzystaj z `npx shadcn@latest`

Niektóre popularne komponenty to:

- Accordion
- Alert
- AlertDialog
- AspectRatio
- Avatar
- Calendar
- Checkbox
- Collapsible
- Command
- ContextMenu
- DataTable
- DatePicker
- Dropdown Menu
- Form
- Hover Card
- Menubar
- Navigation Menu
- Popover
- Progress
- Radio Group
- ScrollArea
- Select
- Separator
- Sheet
- Skeleton
- Slider
- Switch
- Table
- Textarea
- Sonner (previously Toast)
- Toggle
- Tooltip

## Component Styling

Ten projekt wykorzystuje wariant stylu „new-york” z kolorem bazowym "neutral" i zmiennymi CSS do tworzenia motywów, zgodnie z konfiguracją w sekcji `components.json`.


================================================
FILE: .github/copilot-instructions.md
================================================
# AI Rules for {{project-name}}

{{project-description}}

## Tech Stack

- Astro 5
- TypeScript 5
- React 19
- Tailwind 4
- Shadcn/ui

## Project Structure

When introducing changes to the project, always follow the directory structure below:

- `./src` - source code
- `./src/layouts` - Astro layouts
- `./src/pages` - Astro pages
- `./src/pages/api` - API endpoints
- `./src/middleware/index.ts` - Astro middleware
- `./src/db` - Supabase clients and types
- `./src/types.ts` - Shared types for backend and frontend (Entities, DTOs)
- `./src/components` - Client-side components written in Astro (static) and React (dynamic)
- `./src/components/ui` - Client-side components from Shadcn/ui
- `./src/lib` - Services and helpers
- `./src/assets` - static internal assets
- `./public` - public assets

When modifying the directory structure, always update this section.

## Coding practices

### Guidelines for clean code

- Use feedback from linters to improve the code when making changes.
- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deeply nested if statements.
- Place the happy path last in the function for improved readability.
- Avoid unnecessary else statements; use if-return pattern instead.
- Use guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Consider using custom error types or error factories for consistent error handling.

## Frontend

### General Guidelines

- Use Astro components (.astro) for static content and layout
- Implement framework components in React only when interactivity is needed

### Guidelines for Styling

#### Tailwind

- Use the @layer directive to organize styles into components, utilities, and base layers
- Use arbitrary values with square brackets (e.g., w-[123px]) for precise one-off designs
- Implement the Tailwind configuration file for customizing theme, plugins, and variants
- Leverage the theme() function in CSS for accessing Tailwind theme values
- Implement dark mode with the dark: variant
- Use responsive variants (sm:, md:, lg:, etc.) for adaptive designs
- Leverage state variants (hover:, focus-visible:, active:, etc.) for interactive elements

### Guidelines for Accessibility

#### ARIA Best Practices

- Use ARIA landmarks to identify regions of the page (main, navigation, search, etc.)
- Apply appropriate ARIA roles to custom interface elements that lack semantic HTML equivalents
- Set aria-expanded and aria-controls for expandable content like accordions and dropdowns
- Use aria-live regions with appropriate politeness settings for dynamic content updates
- Implement aria-hidden to hide decorative or duplicative content from screen readers
- Apply aria-label or aria-labelledby for elements without visible text labels
- Use aria-describedby to associate descriptive text with form inputs or complex elements
- Implement aria-current for indicating the current item in a set, navigation, or process
- Avoid redundant ARIA that duplicates the semantics of native HTML elements

### Guidelines for Astro

- Leverage View Transitions API for smooth page transitions (use ClientRouter)
- Use content collections with type safety for blog posts, documentation, etc.
- Leverage Server Endpoints for API routes
- Use POST, GET  - uppercase format for endpoint handlers
- Use `export const prerender = false` for API routes
- Use zod for input validation in API routes
- Extract logic into services in `src/lib/services`
- Implement middleware for request/response modification
- Use image optimization with the Astro Image integration
- Implement hybrid rendering with server-side rendering where needed
- Use Astro.cookies for server-side cookie management
- Leverage import.meta.env for environment variables

### Guidelines for React

- Use functional components with hooks instead of class components
- Never use "use client" and other Next.js directives as we use React with Astro
- Extract logic into custom hooks in `src/components/hooks`
- Implement React.memo() for expensive components that render often with the same props
- Utilize React.lazy() and Suspense for code-splitting and performance optimization
- Use the useCallback hook for event handlers passed to child components to prevent unnecessary re-renders
- Prefer useMemo for expensive calculations to avoid recomputation on every render
- Implement useId() for generating unique IDs for accessibility attributes
- Consider using the new useOptimistic hook for optimistic UI updates in forms
- Use useTransition for non-urgent state updates to keep the UI responsive

### Backend and Database

- Use Supabase for backend services, including authentication and database interactions.
- Follow Supabase guidelines for security and performance.
- Use Zod schemas to validate data exchanged with the backend.
- Use supabase from context.locals in Astro routes instead of importing supabaseClient directly
- Use SupabaseClient type from `src/db/supabase.client.ts`, not from `@supabase/supabase-js`


================================================
FILE: .husky/pre-commit
================================================
npx lint-staged



</kod_projektu>

<stos_technologiczny>
[tech-stack.md](mdc:.ai/tech-stack.md)
</stos_technologiczny>

Twoim zadaniem jest wygenerowanie szczegółowego planu testów, który będzie dostosowany do specyfiki projektu, uwzględniając wykorzystywane technologie, strukturę kodu oraz kluczowe elementy repozytorium. Plan testów powinien być napisany w języku polskim.

Przed stworzeniem planu testów, przeprowadź dogłębną analizę projektu wewnątrz bloku <analiza_projektu> w swoim bloku myślowym. W analizie uwzględnij:

1. Kluczowe komponenty projektu wynikające z analizy kodu:
   - Wymień i opisz główne komponenty projektu
2. Specyfikę stosu technologicznego i jego wpływ na strategię testowania:
   - Przeanalizuj każdy element stosu technologicznego i jego implikacje dla testowania
3. Priorytety testowe bazujące na strukturze repozytorium:
   - Zidentyfikuj i uszereguj obszary testowe według ważności
4. Potencjalne obszary ryzyka wymagające szczególnej uwagi w testach:
   - Wymień potencjalne ryzyka i uzasadnij, dlaczego wymagają specjalnej uwagi

Po zakończeniu analizy, stwórz plan testów wewnątrz bloku <plan_testów>. Plan powinien zawierać:

1. Wprowadzenie i cele testowania
2. Zakres testów
3. Typy testów do przeprowadzenia (np. testy jednostkowe, integracyjne, wydajnościowe)
4. Scenariusze testowe dla kluczowych funkcjonalności
5. Środowisko testowe
6. Narzędzia do testowania
7. Harmonogram testów
8. Kryteria akceptacji testów
9. Role i odpowiedzialności w procesie testowania
10. Procedury raportowania błędów

Pamiętaj, aby plan testów był:
- Dokładnie dostosowany do kontekstu projektu
- Uwzględniał specyfikę wykorzystywanych technologii
- Priorytetyzował kluczowe elementy repozytorium
- Był napisany w języku polskim
- Prezentował wysoką jakość i profesjonalizm

Rozpocznij od analizy, a następnie przejdź do tworzenia planu testów. Twój końcowy wynik powinien składać się tylko z planu testów i nie powinien powielać ani streszczać żadnej pracy wykonanej w bloku analizy projektu.

Przedstaw ten plan w formacie Markdown i zapisz w .ai/test-plan.md